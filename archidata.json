{
	"scripts": [
		{
			"id": 78,
			"title": "AnnotationSymbol Placeholder",
			"code": "AnnotationSymbol\n ",
			"description": "This is a placeholder response as no code was provided for analysis. It indicates the absence of actual code and serves as a default response.",
			"likes": 0,
			"created_at": "2025-04-16T10:47:25.044085+00:00"
		},
		{
			"id": 95,
			"title": "Bounding Box Initialization",
			"code": "if not boundingBox or boundingBox.IsEmpty:\n    boundingBox = BoundingBoxXYZ()\n    boundingBox.Min = XYZ(-10, -10, 0)\n    boundingBox.Max = XYZ(10, 10, 0)",
			"description": "This code checks if a bounding box is either null or empty. If so, it initializes the bounding box with default minimum and maximum XYZ coordinates, effectively creating a default bounding box.",
			"likes": 0,
			"created_at": "2025-04-24T13:11:36.221677+00:00"
		},
		{
			"id": 94,
			"title": "Bounding Box Initialization",
			"code": "if not boundingBox or boundingBox.IsEmpty:\n    boundingBox = BoundingBoxXYZ()\n    boundingBox.Min = XYZ(-10, -10, 0)\n    boundingBox.Max = XYZ(10, 10, 0)",
			"description": "This code initializes a bounding box if it's either null or empty. It creates a new BoundingBoxXYZ object and sets its minimum and maximum XYZ coordinates to define a default box spanning from (-10,-10,0) to (10,10,0).",
			"likes": 0,
			"created_at": "2025-04-24T13:09:30.46449+00:00"
		},
		{
			"id": 126,
			"title": "Bounding Box Initialization",
			"code": "if not boundingBox or boundingBox.IsEmpty:\n    boundingBox = BoundingBoxXYZ()\n    boundingBox.Min = XYZ(-10, -10, 0)\n    boundingBox.Max = XYZ(10, 10, 0)",
			"description": "This code initializes a bounding box. If the provided bounding box is null or empty, a new `BoundingBoxXYZ` object is created and its minimum and maximum coordinates are set to default values, effectively defining a default bounding box.",
			"likes": 0,
			"created_at": "2025-05-12T08:21:29.134456+00:00"
		},
		{
			"id": 124,
			"title": "Bounding Box Initialization",
			"code": "if not boundingBox or boundingBox.IsEmpty:\n    boundingBox = BoundingBoxXYZ()\n    boundingBox.Min = XYZ(-10, -10, 0)\n    boundingBox.Max = XYZ(10, 10, 0)",
			"description": "This code initializes a BoundingBoxXYZ object if it's either null or empty. If so, it creates a new bounding box and sets its minimum and maximum XYZ coordinates to default values (from -10 to 10 on X and Y, and 0 on Z).",
			"likes": 0,
			"created_at": "2025-05-10T09:22:42.239163+00:00"
		},
		{
			"id": 138,
			"title": "AnnotationSymbol Placeholder",
			"code": "AnnotationSymbol\n ",
			"description": "This entry serves as a placeholder. No actual code was provided for analysis, so the description is generic. A valid code snippet is required for a proper response.",
			"likes": 0,
			"created_at": "2025-05-16T12:43:14.69932+00:00"
		},
		{
			"id": 93,
			"title": "Bounding Box Initialization",
			"code": "if not boundingBox or boundingBox.IsEmpty:\n    boundingBox = BoundingBoxXYZ()\n    boundingBox.Min = XYZ(-10, -10, 0)\n    boundingBox.Max = XYZ(10, 10, 0)",
			"description": "This code checks if a bounding box exists or is empty. If either condition is true, it creates a new bounding box and initializes its minimum and maximum coordinates to default values.",
			"likes": 0,
			"created_at": "2025-04-24T13:09:17.348487+00:00"
		},
		{
			"id": 108,
			"title": "Revit Element Color Override and IFC Export",
			"code": "import Autodesk\nfrom Autodesk.Revit.DB import *\nfrom Autodesk.Revit.UI import *\nimport clr\nimport System\nfrom System.Collections.Generic import List\nfrom System import Guid\nimport os\n\n# Get application and document\napp = __revit__.Application\ndoc = __revit__.ActiveUIDocument.Document\nuidoc = __revit__.ActiveUIDocument\n\n# Define parameter name to get values from\nparameter_name = \"YourParameterName\"  # Change this to your parameter name\n\n# Define color mapping - modify this dictionary to match your parameter values to colors\n# Format: \"parameter_value\": (red, green, blue)\ncolor_mapping = {\n    \"Value1\": (255, 0, 0),     # Red\n    \"Value2\": (0, 255, 0),     # Green\n    \"Value3\": (0, 0, 255),     # Blue\n    \"Value4\": (255, 255, 0),   # Yellow\n    \"default\": (128, 128, 128) # Gray as default\n}\n\n# Collect all generic model elements\ncollector = FilteredElementCollector(doc).OfCategory(BuiltInCategory.OST_GenericModel).WhereElementIsNotElementType()\nelements = collector.ToElements()\n\n# Transaction to modify visualization\nt = Transaction(doc, \"Prepare Elements for IFC Export\")\nt.Start()\n\n# Create a set of element IDs\nelement_ids = List[ElementId]()\n\ntry:\n    # Create an IFC export configuration\n    export_config = IFCExportConfiguration.CreateDefaultConfiguration()\n    export_config.ExportBaseQuantities = True\n    export_config.FileVersion = IFCVersion.IFC2x3CV2\n    export_config.SpaceBoundaryLevel = 1\n    export_config.WallAndColumnSplitting = True\n    export_config.VisibleElementsOfCurrentView = False\n    export_config.SplitWallsAndColumns = True\n    export_config.Use2DRoomBoundaryForVolume = False\n    \n    # Process each element and apply color overrides\n    for element in elements:\n        # Get parameter value\n        param = element.LookupParameter(parameter_name)\n        \n        if param:\n            param_value = param.AsString()\n            \n            # Find the color for this parameter value\n            if param_value in color_mapping:\n                color_rgb = color_mapping[param_value]\n            else:\n                color_rgb = color_mapping[\"default\"]\n            \n            # Create a new override graphic settings\n            settings = OverrideGraphicSettings()\n            color = Color(color_rgb[0], color_rgb[1], color_rgb[2])\n            settings.SetProjectionLineColor(color)\n            settings.SetCutLineColor(color)\n            settings.SetSurfaceForegroundPatternColor(color)\n            settings.SetSurfaceForegroundPatternId(ElementId(BuiltInFillPatternTarget.Drafting))\n            settings.SetSurfaceForegroundPatternVisible(True)\n            \n            # Apply the override\n            doc.ActiveView.SetElementOverrides(element.Id, settings)\n            \n            # Add to element IDs list for export\n            element_ids.Add(element.Id)\n    \n    # Create a custom IFC export options\n    options = IFCExportOptions()\n    options.FileVersion = IFCVersion.IFC2x3CV2\n    options.ExportBaseQuantities = True\n    options.WallAndColumnSplitting = True\n    options.SpaceBoundaryLevel = 1\n    \n    # Get desktop path for saving IFC file\n    desktop_path = os.path.join(os.path.expanduser(\"~\"), \"Desktop\")\n    ifc_file_path = os.path.join(desktop_path, \"ExportedElements.ifc\")\n    \n    # Complete the transaction\n    t.Commit()\n    \n    # Export to IFC\n    doc.Export(desktop_path, \"ExportedElements\", options)\n    \n    # Display success message\n    TaskDialog.Show(\"Export Complete\", f\"Elements exported to IFC file at:\\n{ifc_file_path}\")",
			"description": "This script overrides the graphic settings of generic model elements in Revit based on a parameter value and a defined color mapping. It then exports these elements to an IFC file, saving it to the desktop.",
			"likes": 0,
			"created_at": "2025-04-30T04:58:51.106746+00:00"
		},
		{
			"id": 70,
			"title": "Adjust Grid Extents to Crop Region with Offset",
			"code": "import clr\nfrom Autodesk.Revit.UI import TaskDialog\nfrom Autodesk.Revit.DB import *\nimport System.Windows.Forms\nfrom System.Windows.Forms import *\nfrom System.Drawing import *\n\ndoc = __revit__.ActiveUIDocument.Document\nuidoc = __revit__.ActiveUIDocument\nview = doc.ActiveView\n\n# Check if active view has crop region enabled\nif not view.CropBoxActive:\n    TaskDialog.Show(\"Error\", \"The active view must have a crop region enabled.\")\n    exit()\n\n# Get all grids in the current view\ncollector = FilteredElementCollector(doc, view.Id).OfCategory(BuiltInCategory.OST_Grids).WhereElementIsNotElementType()\nall_grids = list(collector)\n\nif len(all_grids) == 0:\n    TaskDialog.Show(\"Error\", \"No grids found in the current view.\")\n    exit()\n\n# Create a simple form to get the offset value\nclass OffsetForm(Form):\n    def __init__(self):\n        self.Text = \"Grid Offset from Crop Region\"\n        self.Width = 300\n        self.Height = 150\n        \n        # Offset input\n        self.label = Label()\n        self.label.Text = \"Enter offset distance (in feet):\"\n        self.label.Location = Point(20, 20)\n        self.label.Width = 250\n        \n        self.textBox = TextBox()\n        self.textBox.Text = \"0.25\"\n        self.textBox.Location = Point(20, 50)\n        self.textBox.Width = 240\n        \n        # OK and Cancel buttons\n        self.buttonOK = Button()\n        self.buttonOK.Text = \"OK\"\n        self.buttonOK.Location = Point(100, 80)\n        self.buttonOK.DialogResult = DialogResult.OK\n        \n        self.buttonCancel = Button()\n        self.buttonCancel.Text = \"Cancel\"\n        self.buttonCancel.Location = Point(180, 80)\n        self.buttonCancel.DialogResult = DialogResult.Cancel\n        \n        # Add controls to form\n        self.Controls.Add(self.label)\n        self.Controls.Add(self.textBox)\n        self.Controls.Add(self.buttonOK)\n        self.Controls.Add(self.buttonCancel)\n        \n        # Set OK as accept button\n        self.AcceptButton = self.buttonOK\n\nform = OffsetForm()\nresult = form.ShowDialog()\n\nif result != DialogResult.OK:\n    exit()\n\ntry:\n    offset_feet = float(form.textBox.Text)\nexcept:\n    TaskDialog.Show(\"Error\", \"Please enter a valid number for the offset.\")\n    exit()\n\n# Convert feet to internal Revit units\noffset = offset_feet * 1.0\n\n# Get crop box\ncrop_box = view.CropBox\n\n# Start a transaction\nt = Transaction(doc, \"Align Grids to Crop Region\")\nt.Start()\n\ntry:\n    # Process each grid\n    for grid in all_grids:\n        # Get the grid curve\n        curve = grid.Curve\n        \n        # Check if it's a line\n        if not isinstance(curve, Line):\n            continue\n            \n        # Get the direction of the line\n        direction = curve.Direction\n        \n        # Determine if grid is horizontal or vertical\n        is_horizontal = abs(direction.Y) > abs(direction.X)\n        \n        # Get the crop box boundaries\n        min_point = crop_box.Min\n        max_point = crop_box.Max\n        \n        # Calculate new start and end points based on crop box and offset\n        if is_horizontal:\n            # Horizontal grid\n            new_y = min_point.Y + offset if curve.GetEndPoint(0).Y < (min_point.Y + max_point.Y) / 2 else max_point.Y - offset\n            new_start = XYZ(min_point.X, new_y, 0)\n            new_end = XYZ(max_point.X, new_y, 0)\n        else:\n            # Vertical grid\n            new_x = min",
			"description": "This code extends or shortens grid lines in the active Revit view to align with the crop region boundaries, applying a user-defined offset. It prompts the user for an offset value (in feet) using a simple form and then adjusts the grid extents accordingly.",
			"likes": 0,
			"created_at": "2025-04-14T14:29:58.661828+00:00"
		},
		{
			"id": 143,
			"title": "Annotation Crop Offset Properties",
			"code": "public double RightAnnotationCropOffset { get; set; }\npublic double LeftAnnotationCropOffset { get; set; }\npublic double BottomAnnotationCropOffset { get; set; }\npublic double TopAnnotationCropOffset { get; set; }",
			"description": "This code defines four public properties representing crop offsets for annotations. These properties allow setting offsets for the right, left, bottom, and top edges of an annotation crop region, respectively.",
			"likes": 0,
			"created_at": "2025-05-21T19:50:43.965327+00:00"
		},
		{
			"id": 72,
			"title": "Revit Python: Create Wall",
			"code": "import clr\nfrom Autodesk.Revit.DB import *\nimport Autodesk.Revit.DB as DB\nfrom Autodesk.Revit.UI import *\nfrom System.Collections.Generic import List\n\ndoc = __revit__.ActiveUIDocument.Document\nuidoc = __revit__.ActiveUIDocument\n\n# Start a transaction\nt = Transaction(doc, \"Create Wall\")\nt.Start()\n\n# Get the default wall type\nwall_types = FilteredElementCollector(doc).OfClass(WallType)\nwall_type = wall_types.FirstElement()\n\n# Create a curve for wall path (simple straight line)\nstart_point = XYZ(0, 0, 0)\nend_point = XYZ(10, 0, 0)\ncurve = Line.CreateBound(start_point, end_point)\n\n# Convert feet to internal units (Revit uses feet as internal unit)\nheight = 10.0\n\n# Create the wall\nwall = Wall.Create(doc, curve, wall_type.Id, doc.ActiveView.GenLevel.Id, height, 0, False, False)\n\n# Commit the transaction\nt.Commit()",
			"description": "This code creates a basic wall in the active Revit document. It retrieves the default wall type, defines a straight line for the wall's path, and then creates the wall with a specified height.",
			"likes": 0,
			"created_at": "2025-04-14T19:02:25.513992+00:00"
		},
		{
			"id": 83,
			"title": "Adjust Grid Extents to Crop Region with Offset",
			"code": "import clr\nfrom Autodesk.Revit.UI import TaskDialog\nfrom Autodesk.Revit.DB import *\nimport System.Windows.Forms\nfrom System.Windows.Forms import *\nfrom System.Drawing import *\n\ndoc = __revit__.ActiveUIDocument.Document\nuidoc = __revit__.ActiveUIDocument\nview = doc.ActiveView\n\n# Check if active view has crop region enabled\nif not view.CropBoxActive:\n    TaskDialog.Show(\"Error\", \"The active view must have a crop region enabled.\")\n    exit()\n\n# Get all grids in the current view\ncollector = FilteredElementCollector(doc, view.Id).OfCategory(BuiltInCategory.OST_Grids).WhereElementIsNotElementType()\nall_grids = list(collector)\n\nif len(all_grids) == 0:\n    TaskDialog.Show(\"Error\", \"No grids found in the current view.\")\n    exit()\n\n# Create a simple form to get the offset value\nclass OffsetForm(Form):\n    def __init__(self):\n        self.Text = \"Grid Offset from Crop Region\"\n        self.Width = 300\n        self.Height = 150\n        \n        # Offset input\n        self.label = Label()\n        self.label.Text = \"Enter offset distance (in feet):\"\n        self.label.Location = Point(20, 20)\n        self.label.Width = 250\n        \n        self.textBox = TextBox()\n        self.textBox.Text = \"0.25\"\n        self.textBox.Location = Point(20, 50)\n        self.textBox.Width = 240\n        \n        # OK and Cancel buttons\n        self.buttonOK = Button()\n        self.buttonOK.Text = \"OK\"\n        self.buttonOK.Location = Point(100, 80)\n        self.buttonOK.DialogResult = DialogResult.OK\n        \n        self.buttonCancel = Button()\n        self.buttonCancel.Text = \"Cancel\"\n        self.buttonCancel.Location = Point(180, 80)\n        self.buttonCancel.DialogResult = DialogResult.Cancel\n        \n        # Add controls to form\n        self.Controls.Add(self.label)\n        self.Controls.Add(self.textBox)\n        self.Controls.Add(self.buttonOK)\n        self.Controls.Add(self.buttonCancel)\n        \n        # Set OK as accept button\n        self.AcceptButton = self.buttonOK\n\nform = OffsetForm()\nresult = form.ShowDialog()\n\nif result != DialogResult.OK:\n    exit()\n\ntry:\n    offset_feet = float(form.textBox.Text)\nexcept:\n    TaskDialog.Show(\"Error\", \"Please enter a valid number for the offset.\")\n    exit()\n\n# Convert feet to internal Revit units\noffset = offset_feet * 1.0\n\n# Get crop box\ncrop_box = view.CropBox\n\n# Start a transaction\nt = Transaction(doc, \"Align Grids to Crop Region\")\nt.Start()\n\ntry:\n    # Process each grid\n    for grid in all_grids:\n        # Get the grid curve\n        curve = grid.Curve\n        \n        # Check if it's a line\n        if not isinstance(curve, Line):\n            continue\n            \n        # Get the direction of the line\n        direction = curve.Direction\n        \n        # Determine if grid is horizontal or vertical\n        is_horizontal = abs(direction.Y) > abs(direction.X)\n        \n        # Get the crop box boundaries\n        min_point = crop_box.Min\n        max_point = crop_box.Max\n        \n        # Calculate new start and end points based on crop box and offset\n        if is_horizontal:\n            # Horizontal grid\n            new_y = min_point.Y + offset if curve.GetEndPoint(0).Y < (min_point.Y + max_point.Y) / 2 else max_point.Y - offset\n            new_start = XYZ(min_point.X, new_y, 0)\n            new_end = XYZ(max_point.X, new_y, 0)\n        else:\n            # Vertical grid\n            new_x = min",
			"description": "This code adjusts the extents of grids in the active Revit view to align with the crop region boundaries, allowing for a user-defined offset distance. It prompts the user for an offset value through a Windows form and then modifies the grid extents accordingly.",
			"likes": 0,
			"created_at": "2025-04-18T06:37:25.915462+00:00"
		},
		{
			"id": 43,
			"title": "Adjust Grid Extents to Crop Region with Offset",
			"code": "import clr\nfrom Autodesk.Revit.UI import TaskDialog\nfrom Autodesk.Revit.DB import *\nimport System.Windows.Forms\nfrom System.Windows.Forms import *\nfrom System.Drawing import *\n\ndoc = __revit__.ActiveUIDocument.Document\nuidoc = __revit__.ActiveUIDocument\nview = doc.ActiveView\n\n# Check if active view has crop region enabled\nif not view.CropBoxActive:\n    TaskDialog.Show(\"Error\", \"The active view must have a crop region enabled.\")\n    exit()\n\n# Get all grids in the current view\ncollector = FilteredElementCollector(doc, view.Id).OfCategory(BuiltInCategory.OST_Grids).WhereElementIsNotElementType()\nall_grids = list(collector)\n\nif len(all_grids) == 0:\n    TaskDialog.Show(\"Error\", \"No grids found in the current view.\")\n    exit()\n\n# Create a simple form to get the offset value\nclass OffsetForm(Form):\n    def __init__(self):\n        self.Text = \"Grid Offset from Crop Region\"\n        self.Width = 300\n        self.Height = 150\n        \n        # Offset input\n        self.label = Label()\n        self.label.Text = \"Enter offset distance (in feet):\"\n        self.label.Location = Point(20, 20)\n        self.label.Width = 250\n        \n        self.textBox = TextBox()\n        self.textBox.Text = \"0.25\"\n        self.textBox.Location = Point(20, 50)\n        self.textBox.Width = 240\n        \n        # OK and Cancel buttons\n        self.buttonOK = Button()\n        self.buttonOK.Text = \"OK\"\n        self.buttonOK.Location = Point(100, 80)\n        self.buttonOK.DialogResult = DialogResult.OK\n        \n        self.buttonCancel = Button()\n        self.buttonCancel.Text = \"Cancel\"\n        self.buttonCancel.Location = Point(180, 80)\n        self.buttonCancel.DialogResult = DialogResult.Cancel\n        \n        # Add controls to form\n        self.Controls.Add(self.label)\n        self.Controls.Add(self.textBox)\n        self.Controls.Add(self.buttonOK)\n        self.Controls.Add(self.buttonCancel)\n        \n        # Set OK as accept button\n        self.AcceptButton = self.buttonOK\n\nform = OffsetForm()\nresult = form.ShowDialog()\n\nif result != DialogResult.OK:\n    exit()\n\ntry:\n    offset_feet = float(form.textBox.Text)\nexcept:\n    TaskDialog.Show(\"Error\", \"Please enter a valid number for the offset.\")\n    exit()\n\n# Convert feet to internal Revit units\noffset = offset_feet * 1.0\n\n# Get crop box\ncrop_box = view.CropBox\n\n# Start a transaction\nt = Transaction(doc, \"Align Grids to Crop Region\")\nt.Start()\n\ntry:\n    # Process each grid\n    for grid in all_grids:\n        # Get the grid curve\n        curve = grid.Curve\n        \n        # Check if it's a line\n        if not isinstance(curve, Line):\n            continue\n            \n        # Get the direction of the line\n        direction = curve.Direction\n        \n        # Determine if grid is horizontal or vertical\n        is_horizontal = abs(direction.Y) > abs(direction.X)\n        \n        # Get the crop box boundaries\n        min_point = crop_box.Min\n        max_point = crop_box.Max\n        \n        # Calculate new start and end points based on crop box and offset\n        if is_horizontal:\n            # Horizontal grid\n            new_y = min_point.Y + offset if curve.GetEndPoint(0).Y < (min_point.Y + max_point.Y) / 2 else max_point.Y - offset\n            new_start = XYZ(min_point.X, new_y, 0)\n            new_end = XYZ(max_point.X, new_y, 0)\n        else:\n            # Vertical grid\n            new_x = min",
			"description": "This code adjusts the extents of grids in the active Revit view to align with the crop region boundaries, applying a user-defined offset. It prompts the user for an offset distance, verifies a crop region exists, and modifies horizontal/vertical grid lines.",
			"likes": 0,
			"created_at": "2025-04-02T01:20:15.288492+00:00"
		},
		{
			"id": 26,
			"title": "Create Wall in Revit using Revit API",
			"code": "import clr\nfrom Autodesk.Revit.DB import *\nimport Autodesk.Revit.DB as DB\nfrom Autodesk.Revit.UI import *\nfrom System.Collections.Generic import List\n\ndoc = __revit__.ActiveUIDocument.Document\nuidoc = __revit__.ActiveUIDocument\n\n# Start a transaction\nt = Transaction(doc, \"Create Wall\")\nt.Start()\n\n# Get the default wall type\nwall_types = FilteredElementCollector(doc).OfClass(WallType)\nwall_type = wall_types.FirstElement()\n\n# Create a curve for wall path (simple straight line)\nstart_point = XYZ(0, 0, 0)\nend_point = XYZ(10, 0, 0)\ncurve = Line.CreateBound(start_point, end_point)\n\n# Convert feet to internal units (Revit uses feet as internal unit)\nheight = 10.0\n\n# Create the wall\nwall = Wall.Create(doc, curve, wall_type.Id, doc.ActiveView.GenLevel.Id, height, 0, False, False)\n\n# Commit the transaction\nt.Commit()",
			"description": "This script creates a basic wall in the active Revit document. It gets the default wall type, defines a straight line for the wall's location, and creates the wall with a specified height.",
			"likes": 0,
			"created_at": "2025-03-25T08:25:00.745402+00:00"
		},
		{
			"id": 106,
			"title": "Revit Color Override and IFC Export",
			"code": "import Autodesk\nfrom Autodesk.Revit.DB import *\nfrom Autodesk.Revit.UI import *\nimport clr\nimport System\nfrom System.Collections.Generic import List\nfrom System import Guid\nimport os\n\n# Get application and document\napp = __revit__.Application\ndoc = __revit__.ActiveUIDocument.Document\nuidoc = __revit__.ActiveUIDocument\n\n# Define parameter name to get values from\nparameter_name = \"YourParameterName\"  # Change this to your parameter name\n\n# Define color mapping - modify this dictionary to match your parameter values to colors\n# Format: \"parameter_value\": (red, green, blue)\ncolor_mapping = {\n    \"Value1\": (255, 0, 0),     # Red\n    \"Value2\": (0, 255, 0),     # Green\n    \"Value3\": (0, 0, 255),     # Blue\n    \"Value4\": (255, 255, 0),   # Yellow\n    \"default\": (128, 128, 128) # Gray as default\n}\n\n# Collect all generic model elements\ncollector = FilteredElementCollector(doc).OfCategory(BuiltInCategory.OST_GenericModel).WhereElementIsNotElementType()\nelements = collector.ToElements()\n\n# Transaction to modify visualization\nt = Transaction(doc, \"Prepare Elements for IFC Export\")\nt.Start()\n\n# Create a set of element IDs\nelement_ids = List[ElementId]()\n\ntry:\n    # Create an IFC export configuration\n    export_config = IFCExportConfiguration.CreateDefaultConfiguration()\n    export_config.ExportBaseQuantities = True\n    export_config.FileVersion = IFCVersion.IFC2x3CV2\n    export_config.SpaceBoundaryLevel = 1\n    export_config.WallAndColumnSplitting = True\n    export_config.VisibleElementsOfCurrentView = False\n    export_config.SplitWallsAndColumns = True\n    export_config.Use2DRoomBoundaryForVolume = false\n    \n    # Process each element and apply color overrides\n    for element in elements:\n        # Get parameter value\n        param = element.LookupParameter(parameter_name)\n        \n        if param:\n            param_value = param.AsString()\n            \n            # Find the color for this parameter value\n            if param_value in color_mapping:\n                color_rgb = color_mapping[param_value]\n            else:\n                color_rgb = color_mapping[\"default\"]\n            \n            # Create a new override graphic settings\n            settings = OverrideGraphicSettings()\n            color = Color(color_rgb[0], color_rgb[1], color_rgb[2])\n            settings.SetProjectionLineColor(color)\n            settings.SetCutLineColor(color)\n            settings.SetSurfaceForegroundPatternColor(color)\n            settings.SetSurfaceForegroundPatternId(ElementId(BuiltInFillPatternTarget.Drafting))\n            settings.SetSurfaceForegroundPatternVisible(True)\n            \n            # Apply the override\n            doc.ActiveView.SetElementOverrides(element.Id, settings)\n            \n            # Add to element IDs list for export\n            element_ids.Add(element.Id)\n    \n    # Create a custom IFC export options\n    options = IFCExportOptions()\n    options.FileVersion = IFCVersion.IFC2x3CV2\n    options.ExportBaseQuantities = True\n    options.WallAndColumnSplitting = True\n    options.SpaceBoundaryLevel = 1\n    options.AddOption(\"ExportSpecificElements\", \"1\")\n    options.AddOption(\"ElementsForExport\", \",\".join([str(id.IntegerValue) for id in element_ids]))\n    options.AddOption(\"ExportColors\", \"1\")\n    options.AddOption(\"VisibleElementsOfCurrentView\", \"0\")\n    options.AddOption(\"ColorMode\", \"2\")  # Try with specific color mode\n    options.AddOption(\"ExportElementColors\", \"1\")\n    \n    # Determine export path\n    desktop_path = os.path.join(os.path.expanduser(\"",
			"description": "This script applies color overrides to generic model elements in Revit based on a specified parameter value and a defined color mapping. It then exports those elements to an IFC file with custom export options, including the applied colors.",
			"likes": 0,
			"created_at": "2025-04-28T12:43:24.109268+00:00"
		},
		{
			"id": 39,
			"title": "Revit CAD Importer",
			"code": "# This script imports a CAD file into Revit\n\nimport clr\nimport os\nfrom Autodesk.Revit.DB import *\nfrom Autodesk.Revit.UI import *\nfrom System.Windows.Forms import OpenFileDialog, DialogResult\n\n# Get the current Revit document\ndoc = __revit__.ActiveUIDocument.Document\nuidoc = __revit__.ActiveUIDocument\n\n# Function to get CAD file from user\ndef get_cad_file():\n    dialog = OpenFileDialog()\n    dialog.Filter = \"CAD Files (*.dwg;*.dxf)|*.dwg;*.dxf|All files (*.*)|*.*\"\n    dialog.Title = \"Select CAD File to Import\"\n    \n    if dialog.ShowDialog() == DialogResult.OK:\n        return dialog.FileName\n    return None\n\n# Main execution\ncad_file = get_cad_file()\n\nif cad_file:\n    # Create import options\n    options = DWGImportOptions()\n    options.AutoCADVersion = ACADVersion.Default\n    options.Placement = ImportPlacement.Origin\n    options.ThisViewOnly = False\n    options.ColorMode = ImportColorMode.BlackAndWhite\n    options.CustomScale = 1.0\n    \n    # Start transaction\n    t = Transaction(doc, \"Import CAD\")\n    t.Start()\n    \n    try:\n        # Import the CAD file\n        doc.Import(cad_file, options, doc.ActiveView)\n        t.Commit()\n        TaskDialog.Show(\"Success\", \"CAD file was successfully imported into Revit.\")\n    except Exception as e:\n        t.RollBack()\n        TaskDialog.Show(\"Error\", \"Failed to import CAD file.\\n\" + str(e))\nelse:\n    TaskDialog.Show(\"Cancelled\", \"Operation was cancelled by user.\")",
			"description": "This script imports a CAD file (DWG or DXF) into the active Revit document. It prompts the user to select a CAD file and then imports it using specified options, handling potential errors during the import process.",
			"likes": 0,
			"created_at": "2025-03-30T06:59:37.187293+00:00"
		},
		{
			"id": 107,
			"title": "Color Override and IFC Export of Generic Models",
			"code": "import Autodesk\nfrom Autodesk.Revit.DB import *\nfrom Autodesk.Revit.UI import *\nimport clr\nimport System\nfrom System.Collections.Generic import List\nfrom System import Guid\nimport os\n\n# Get application and document\napp = __revit__.Application\ndoc = __revit__.ActiveUIDocument.Document\nuidoc = __revit__.ActiveUIDocument\n\n# Define parameter name to get values from\nparameter_name = \"YourParameterName\"  # Change this to your parameter name\n\n# Define color mapping - modify this dictionary to match your parameter values to colors\n# Format: \"parameter_value\": (red, green, blue)\ncolor_mapping = {\n    \"Value1\": (255, 0, 0),     # Red\n    \"Value2\": (0, 255, 0),     # Green\n    \"Value3\": (0, 0, 255),     # Blue\n    \"Value4\": (255, 255, 0),   # Yellow\n    \"default\": (128, 128, 128) # Gray as default\n}\n\n# Collect all generic model elements\ncollector = FilteredElementCollector(doc).OfCategory(BuiltInCategory.OST_GenericModel).WhereElementIsNotElementType()\nelements = collector.ToElements()\n\n# Transaction to modify visualization\nt = Transaction(doc, \"Prepare Elements for IFC Export\")\nt.Start()\n\n# Create a set of element IDs\nelement_ids = List[ElementId]()\n\ntry:\n    # Create an IFC export configuration\n    export_config = IFCExportConfiguration.CreateDefaultConfiguration()\n    export_config.ExportBaseQuantities = True\n    export_config.FileVersion = IFCVersion.IFC2x3CV2\n    export_config.SpaceBoundaryLevel = 1\n    export_config.WallAndColumnSplitting = True\n    export_config.VisibleElementsOfCurrentView = False\n    export_config.SplitWallsAndColumns = True\n    export_config.Use2DRoomBoundaryForVolume = false\n    \n    # Process each element and apply color overrides\n    for element in elements:\n        # Get parameter value\n        param = element.LookupParameter(parameter_name)\n        \n        if param:\n            param_value = param.AsString()\n            \n            # Find the color for this parameter value\n            if param_value in color_mapping:\n                color_rgb = color_mapping[param_value]\n            else:\n                color_rgb = color_mapping[\"default\"]\n            \n            # Create a new override graphic settings\n            settings = OverrideGraphicSettings()\n            color = Color(color_rgb[0], color_rgb[1], color_rgb[2])\n            settings.SetProjectionLineColor(color)\n            settings.SetCutLineColor(color)\n            settings.SetSurfaceForegroundPatternColor(color)\n            settings.SetSurfaceForegroundPatternId(ElementId(BuiltInFillPatternTarget.Drafting))\n            settings.SetSurfaceForegroundPatternVisible(True)\n            \n            # Apply the override\n            doc.ActiveView.SetElementOverrides(element.Id, settings)\n            \n            # Add to element IDs list for export\n            element_ids.Add(element.Id)\n    \n    # Create a custom IFC export options\n    options = IFCExportOptions()\n    options.FileVersion = IFCVersion.IFC2x3CV2\n    options.ExportBaseQuantities = True\n    options.WallAndColumnSplitting = True\n    options.SpaceBoundaryLevel = 1\n    options.AddOption(\"ExportSpecificElements\", \"1\")\n    options.AddOption(\"ElementsForExport\", \",\".join([str(id.IntegerValue) for id in element_ids]))\n    options.AddOption(\"ExportColors\", \"1\")\n    options.AddOption(\"VisibleElementsOfCurrentView\", \"0\")\n    options.AddOption(\"ColorMode\", \"2\")  # Try with specific color mode\n    options.AddOption(\"ExportElementColors\", \"1\")",
			"description": "This script finds all generic model elements in a Revit document, colors them based on a parameter value, and prepares these elements for a custom IFC export. It sets graphic overrides on the elements in the active view based on a color mapping defined in the script.",
			"likes": 0,
			"created_at": "2025-04-30T04:57:49.917489+00:00"
		},
		{
			"id": 30,
			"title": "Create a Wall in Revit using Python",
			"code": "import clr\nfrom Autodesk.Revit.DB import *\nimport Autodesk.Revit.DB as DB\nfrom Autodesk.Revit.UI import *\nfrom System.Collections.Generic import List\n\ndoc = __revit__.ActiveUIDocument.Document\nuidoc = __revit__.ActiveUIDocument\n\n# Start a transaction\nt = Transaction(doc, \"Create Wall\")\nt.Start()\n\n# Get the default wall type\nwall_types = FilteredElementCollector(doc).OfClass(WallType)\nwall_type = wall_types.FirstElement()\n\n# Create a curve for wall path (simple straight line)\nstart_point = XYZ(0, 0, 0)\nend_point = XYZ(10, 0, 0)\ncurve = Line.CreateBound(start_point, end_point)\n\n# Convert feet to internal units (Revit uses feet as internal unit)\nheight = 10.0\n\n# Create the wall\nwall = Wall.Create(doc, curve, wall_type.Id, doc.ActiveView.GenLevel.Id, height, 0, False, False)\n\n# Commit the transaction\nt.Commit()",
			"description": "This script creates a straight wall in the active Revit document. It retrieves the default wall type, defines a line as the wall's base curve, and then creates the wall with a specified height.",
			"likes": 0,
			"created_at": "2025-03-26T20:13:11.318838+00:00"
		},
		{
			"id": 66,
			"title": "Concrete 3-Story Structure Modeling",
			"code": "3 story concrete structure modelling",
			"description": "This code likely defines a structural model of a 3-story concrete building. It may involve specifying the geometry, material properties, and structural elements of the building to simulate its behavior under various loads.",
			"likes": 0,
			"created_at": "2025-04-10T15:49:10.27907+00:00"
		},
		{
			"id": 36,
			"title": "Create a Wall in Revit using Python",
			"code": "import clr\nfrom Autodesk.Revit.DB import *\nimport Autodesk.Revit.DB as DB\nfrom Autodesk.Revit.UI import *\nfrom System.Collections.Generic import List\n\ndoc = __revit__.ActiveUIDocument.Document\nuidoc = __revit__.ActiveUIDocument\n\n# Start a transaction\nt = Transaction(doc, \"Create Wall\")\nt.Start()\n\n# Get the default wall type\nwall_types = FilteredElementCollector(doc).OfClass(WallType)\nwall_type = wall_types.FirstElement()\n\n# Create a curve for wall path (simple straight line)\nstart_point = XYZ(0, 0, 0)\nend_point = XYZ(10, 0, 0)\ncurve = Line.CreateBound(start_point, end_point)\n\n# Convert feet to internal units (Revit uses feet as internal unit)\nheight = 10.0\n\n# Create the wall\nwall = Wall.Create(doc, curve, wall_type.Id, doc.ActiveView.GenLevel.Id, height, 0, False, False)\n\n# Commit the transaction\nt.Commit()",
			"description": "This code snippet creates a wall in the active Revit document. It retrieves the default wall type, defines a straight line as the wall's path, and then generates the wall with a specified height using the Revit API within a transaction.",
			"likes": 0,
			"created_at": "2025-03-28T07:15:01.018214+00:00"
		},
		{
			"id": 88,
			"title": "Parameter Retrieval",
			"code": "get a parameter\n",
			"description": "This code snippet retrieves a parameter. The exact mechanism of retrieval is not specified in the given code fragment but it suggests an operation to access a stored parameter value.",
			"likes": 0,
			"created_at": "2025-04-22T07:51:10.961603+00:00"
		},
		{
			"id": 110,
			"title": "Bounding Box Initialization",
			"code": "if not boundingBox or boundingBox.IsEmpty:\n    boundingBox = BoundingBoxXYZ()\n    boundingBox.Min = XYZ(-10, -10, 0)\n    boundingBox.Max = XYZ(10, 10, 0)",
			"description": "This code snippet checks if a bounding box exists or is empty. If it doesn't, it creates a new `BoundingBoxXYZ` object and initializes its minimum and maximum coordinates to form a box spanning from (-10, -10, 0) to (10, 10, 0).",
			"likes": 0,
			"created_at": "2025-05-01T14:29:02.493991+00:00"
		},
		{
			"id": 65,
			"title": "Align Grids to Crop Region with Offset",
			"code": "import clr\nfrom Autodesk.Revit.UI import TaskDialog\nfrom Autodesk.Revit.DB import *\nimport System.Windows.Forms\nfrom System.Windows.Forms import *\nfrom System.Drawing import *\n\ndoc = __revit__.ActiveUIDocument.Document\nuidoc = __revit__.ActiveUIDocument\nview = doc.ActiveView\n\n# Check if active view has crop region enabled\nif not view.CropBoxActive:\n    TaskDialog.Show(\"Error\", \"The active view must have a crop region enabled.\")\n    exit()\n\n# Get all grids in the current view\ncollector = FilteredElementCollector(doc, view.Id).OfCategory(BuiltInCategory.OST_Grids).WhereElementIsNotElementType()\nall_grids = list(collector)\n\nif len(all_grids) == 0:\n    TaskDialog.Show(\"Error\", \"No grids found in the current view.\")\n    exit()\n\n# Create a simple form to get the offset value\nclass OffsetForm(Form):\n    def __init__(self):\n        self.Text = \"Grid Offset from Crop Region\"\n        self.Width = 300\n        self.Height = 150\n        \n        # Offset input\n        self.label = Label()\n        self.label.Text = \"Enter offset distance (in feet):\"\n        self.label.Location = Point(20, 20)\n        self.label.Width = 250\n        \n        self.textBox = TextBox()\n        self.textBox.Text = \"0.25\"\n        self.textBox.Location = Point(20, 50)\n        self.textBox.Width = 240\n        \n        # OK and Cancel buttons\n        self.buttonOK = Button()\n        self.buttonOK.Text = \"OK\"\n        self.buttonOK.Location = Point(100, 80)\n        self.buttonOK.DialogResult = DialogResult.OK\n        \n        self.buttonCancel = Button()\n        self.buttonCancel.Text = \"Cancel\"\n        self.buttonCancel.Location = Point(180, 80)\n        self.buttonCancel.DialogResult = DialogResult.Cancel\n        \n        # Add controls to form\n        self.Controls.Add(self.label)\n        self.Controls.Add(self.textBox)\n        self.Controls.Add(self.buttonOK)\n        self.Controls.Add(self.buttonCancel)\n        \n        # Set OK as accept button\n        self.AcceptButton = self.buttonOK\n\nform = OffsetForm()\nresult = form.ShowDialog()\n\nif result != DialogResult.OK:\n    exit()\n\ntry:\n    offset_feet = float(form.textBox.Text)\nexcept:\n    TaskDialog.Show(\"Error\", \"Please enter a valid number for the offset.\")\n    exit()\n\n# Convert feet to internal Revit units\noffset = offset_feet * 1.0\n\n# Get crop box\ncrop_box = view.CropBox\n\n# Start a transaction\nt = Transaction(doc, \"Align Grids to Crop Region\")\nt.Start()\n\ntry:\n    # Process each grid\n    for grid in all_grids:\n        # Get the grid curve\n        curve = grid.Curve\n        \n        # Check if it's a line\n        if not isinstance(curve, Line):\n            continue\n            \n        # Get the direction of the line\n        direction = curve.Direction\n        \n        # Determine if grid is horizontal or vertical\n        is_horizontal = abs(direction.Y) > abs(direction.X)\n        \n        # Get the crop box boundaries\n        min_point = crop_box.Min\n        max_point = crop_box.Max\n        \n        # Calculate new start and end points based on crop box and offset\n        if is_horizontal:\n            # Horizontal grid\n            new_y = min_point.Y + offset if curve.GetEndPoint(0).Y < (min_point.Y + max_point.Y) / 2 else max_point.Y - offset\n            new_start = XYZ(min_point.X, new_y, 0)\n            new_end = XYZ(max_point.X, new_y, 0)\n        else:\n            # Vertical grid\n            new_x = min",
			"description": "This script aligns grid lines in the active Revit view to the crop region boundaries with a specified offset. It prompts the user for an offset distance and adjusts the grid extents accordingly, ensuring grids extend just beyond the crop boundary.",
			"likes": 0,
			"created_at": "2025-04-10T10:46:32.953951+00:00"
		},
		{
			"id": 38,
			"title": "Revit Dimension Creator",
			"code": "import clr\nclr.AddReference('RevitAPI')\nclr.AddReference('RevitAPIUI')\nfrom Autodesk.Revit.DB import *\nfrom Autodesk.Revit.UI import *\n\ndoc = __revit__.ActiveUIDocument.Document\nuidoc = __revit__.ActiveUIDocument\n\n# Collect all walls, doors, and windows\nwalls = FilteredElementCollector(doc).OfCategory(BuiltInCategory.OST_Walls).WhereElementIsNotElementType().ToElements()\ndoors = FilteredElementCollector(doc).OfCategory(BuiltInCategory.OST_Doors).WhereElementIsNotElementType().ToElements()\nwindows = FilteredElementCollector(doc).OfCategory(BuiltInCategory.OST_Windows).WhereElementIsNotElementType().ToElements()\n\nt = Transaction(doc, \"Create Dimensions\")\nt.Start()\n\n# Create dimensions for walls\nfor wall in walls:\n    loc = wall.Location\n    if isinstance(loc, LocationCurve):\n        curve = loc.Curve\n        p1 = curve.GetEndPoint(0)\n        p2 = curve.GetEndPoint(1)\n        line = Line.CreateBound(p1, p2)\n        ref_array = ReferenceArray()\n        ref_array.Append(wall.References[0])\n        ref_array.Append(wall.References[1])\n        try:\n            dim = doc.Create.NewDimension(doc.ActiveView, line, ref_array)\n        except:\n            continue\n\n# Create dimensions for doors and windows\nfor element in list(doors) + list(windows):\n    try:\n        host = element.Host\n        if isinstance(host, Wall):\n            face_ref = host.References[0]\n            opening_refs = element.References\n            ref_array = ReferenceArray()\n            ref_array.Append(face_ref)\n            ref_array.Append(opening_refs[0])\n            \n            bb = element.get_BoundingBox(doc.ActiveView)\n            p1 = XYZ(bb.Min.X, bb.Min.Y, bb.Min.Z)\n            p2 = XYZ(bb.Max.X, bb.Min.Y, bb.Min.Z)\n            line = Line.CreateBound(p1, p2)\n            \n            dim = doc.Create.NewDimension(doc.ActiveView, line, ref_array)\n    except:\n        continue\n\nt.Commit()",
			"description": "This script automatically creates dimensions for walls, doors, and windows in the active Revit document. It retrieves all elements of these categories and generates dimensions based on their location and geometry, relative to the host wall.",
			"likes": 0,
			"created_at": "2025-03-30T06:51:08.314851+00:00"
		},
		{
			"id": 102,
			"title": "Relocate Revit Project Based on CAD Import Coordinates",
			"code": "import clr\nimport Autodesk\nfrom Autodesk.Revit.DB import *\nfrom Autodesk.Revit.UI import *\nfrom System.Collections.Generic import List\n\ndoc = __revit__.ActiveUIDocument.Document\nuidoc = __revit__.ActiveUIDocument\n\n# Get all CAD imports in the project\ncollector = FilteredElementCollector(doc).OfClass(ImportInstance)\ncad_imports = list(collector)\n\nif not cad_imports:\n    TaskDialog.Show(\"Error\", \"No CAD imports found in the document.\")\nelse:\n    # Start a transaction\n    t = Transaction(doc, \"Relocate Project Based on CAD Coordinates\")\n    t.Start()\n    \n    try:\n        # Get the first CAD import's coordinate system\n        cad_import = cad_imports[0]\n        \n        # Get the transform from the CAD import\n        transform = cad_import.GetTotalTransform()\n        \n        # Get the project base point\n        collector = FilteredElementCollector(doc).OfCategory(BuiltInCategory.OST_ProjectBasePoint)\n        base_point = collector.FirstElement()\n        \n        if base_point:\n            # Get current position parameters\n            param_n = base_point.get_Parameter(BuiltInParameter.BASEPOINT_NORTHSOUTH_PARAM)\n            param_e = base_point.get_Parameter(BuiltInParameter.BASEPOINT_EASTWEST_PARAM)\n            param_elev = base_point.get_Parameter(BuiltInParameter.BASEPOINT_ELEVATION_PARAM)\n            \n            # Extract translation values from the transform\n            translation = transform.Origin\n            \n            # Set the project base point to match the CAD import origin\n            param_e.Set(translation.X)\n            param_n.Set(translation.Y)\n            param_elev.Set(translation.Z)\n            \n            TaskDialog.Show(\"Success\", \"Project relocated based on CAD import coordinates.\")\n        else:\n            TaskDialog.Show(\"Error\", \"Project base point not found.\")\n            \n        t.Commit()\n    except Exception as e:\n        t.RollBack()\n        TaskDialog.Show(\"Error\", \"Failed to relocate project: \" + str(e))",
			"description": "This script relocates the Revit project's base point to match the origin of the first CAD import found in the document. It retrieves the CAD import's transformation matrix, extracts the origin coordinates, and then sets the project base point's north/south, east/west, and elevation parameters to these values.",
			"likes": 0,
			"created_at": "2025-04-26T05:53:30.788735+00:00"
		},
		{
			"id": 13,
			"title": "Revit Dimension Creator",
			"code": "import clr\nclr.AddReference('RevitAPI')\nclr.AddReference('RevitAPIUI')\nfrom Autodesk.Revit.DB import *\nfrom Autodesk.Revit.UI import *\n\ndoc = __revit__.ActiveUIDocument.Document\nuidoc = __revit__.ActiveUIDocument\n\n# Collect all walls, doors, and windows\nwalls = FilteredElementCollector(doc).OfCategory(BuiltInCategory.OST_Walls).WhereElementIsNotElementType().ToElements()\ndoors = FilteredElementCollector(doc).OfCategory(BuiltInCategory.OST_Doors).WhereElementIsNotElementType().ToElements()\nwindows = FilteredElementCollector(doc).OfCategory(BuiltInCategory.OST_Windows).WhereElementIsNotElementType().ToElements()\n\nt = Transaction(doc, \"Create Dimensions\")\nt.Start()\n\n# Create dimensions for walls\nfor wall in walls:\n    loc = wall.Location\n    if isinstance(loc, LocationCurve):\n        curve = loc.Curve\n        p1 = curve.GetEndPoint(0)\n        p2 = curve.GetEndPoint(1)\n        line = Line.CreateBound(p1, p2)\n        ref_array = ReferenceArray()\n        ref_array.Append(wall.References[0])\n        ref_array.Append(wall.References[1])\n        try:\n            dim = doc.Create.NewDimension(doc.ActiveView, line, ref_array)\n        except:\n            continue\n\n# Create dimensions for doors and windows\nfor element in list(doors) + list(windows):\n    try:\n        host = element.Host\n        if isinstance(host, Wall):\n            face_ref = host.References[0]\n            opening_refs = element.References\n            ref_array = ReferenceArray()\n            ref_array.Append(face_ref)\n            ref_array.Append(opening_refs[0])\n            \n            bb = element.get_BoundingBox(doc.ActiveView)\n            p1 = XYZ(bb.Min.X, bb.Min.Y, bb.Min.Z)\n            p2 = XYZ(bb.Max.X, bb.Min.Y, bb.Min.Z)\n            line = Line.CreateBound(p1, p2)\n            \n            dim = doc.Create.NewDimension(doc.ActiveView, line, ref_array)\n    except:\n        continue\n\nt.Commit()",
			"description": "This script automates the creation of dimensions in a Revit document. It collects walls, doors, and windows, then generates dimensions along walls and between wall faces and door/window openings. The script handles potential errors during dimension creation gracefully.",
			"likes": 0,
			"created_at": "2025-03-14T12:36:21.028499+00:00"
		},
		{
			"id": 15,
			"title": "Revit Dimension Creator",
			"code": "```python\nimport clr\nclr.AddReference('RevitAPI')\nclr.AddReference('RevitAPIUI')\nfrom Autodesk.Revit.DB import *\nfrom Autodesk.Revit.UI import *\n\ndoc = __revit__.ActiveUIDocument.Document\nuidoc = __revit__.ActiveUIDocument\n\n# Collect all walls, doors, and windows\nwalls = FilteredElementCollector(doc).OfCategory(BuiltInCategory.OST_Walls).WhereElementIsNotElementType().ToElements()\ndoors = FilteredElementCollector(doc).OfCategory(BuiltInCategory.OST_Doors).WhereElementIsNotElementType().ToElements()\nwindows = FilteredElementCollector(doc).OfCategory(BuiltInCategory.OST_Windows).WhereElementIsNotElementType().ToElements()\n\nt = Transaction(doc, \"Create Dimensions\")\nt.Start()\n\n# Create dimensions for walls\nfor wall in walls:\n    loc = wall.Location\n    if isinstance(loc, LocationCurve):\n        curve = loc.Curve\n        p1 = curve.GetEndPoint(0)\n        p2 = curve.GetEndPoint(1)\n        line = Line.CreateBound(p1, p2)\n        ref_array = ReferenceArray()\n        ref_array.Append(wall.References[0])\n        ref_array.Append(wall.References[1])\n        try:\n            dim = doc.Create.NewDimension(doc.ActiveView, line, ref_array)\n        except:\n            continue\n\n# Create dimensions for doors and windows \nfor element in list(doors) + list(windows):\n    try:\n        host = element.Host\n        if isinstance(host, Wall):\n            face_ref = host.References[0]\n            opening_refs = element.References\n            ref_array = ReferenceArray()\n            ref_array.Append(face_ref)\n            ref_array.Append(opening_refs[0])\n            \n            bb = element.get_BoundingBox(doc.ActiveView)\n            p1 = XYZ(bb.Min.X, bb.Min.Y, bb.Min.Z)\n            p2 = XYZ(bb.Max.X, bb.Min.Y, bb.Min.Z)\n            line = Line.CreateBound(p1, p2)\n            \n            dim = doc.Create.NewDimension(doc.ActiveView, line, ref_array)\n    except:\n        continue\n\nt.Commit()\n```",
			"description": "This script automatically creates dimensions for walls, doors, and windows in the active Revit document. It iterates through each element type, retrieves necessary references, and generates dimensions relative to the active view.",
			"likes": 0,
			"created_at": "2025-03-21T04:33:22.018307+00:00"
		},
		{
			"id": 79,
			"title": "Simple Property Declaration",
			"code": "public string ItemNumber { get; set; }",
			"description": "This code declares a public string property named 'ItemNumber'. It includes both a getter and a setter, allowing read and write access to the property from anywhere.",
			"likes": 0,
			"created_at": "2025-04-17T07:21:39.879763+00:00"
		},
		{
			"id": 98,
			"title": "Automated Google Sheets Creation",
			"code": "auto sheets creation",
			"description": "This code automates the creation of new Google Sheets. It likely uses a scripting language like Google Apps Script or Python with the Google Sheets API to generate and configure spreadsheets.",
			"likes": 0,
			"created_at": "2025-04-25T05:31:18.66133+00:00"
		},
		{
			"id": 145,
			"title": "AnnotationSymbol Placeholder",
			"code": "AnnotationSymbol\n ",
			"description": "This entry serves as a placeholder as no actual code was provided. It indicates the intention to analyze a code snippet named 'AnnotationSymbol' and describe its function.",
			"likes": 0,
			"created_at": "2025-05-22T08:58:58.166847+00:00"
		},
		{
			"id": 141,
			"title": "Dynamo Duct Creation Script",
			"code": "create duct for dynamo",
			"description": "This script likely defines a Dynamo graph or Python script intended to automate the creation of ductwork within a BIM environment, such as Revit. It facilitates parametric duct modeling based on user-defined parameters or data inputs.",
			"likes": 0,
			"created_at": "2025-05-19T01:39:06.875179+00:00"
		},
		{
			"id": 74,
			"title": "Revit Font Changer Add-in",
			"code": "# Import necessary libraries\nimport clr\nfrom Autodesk.Revit.DB import *\nfrom Autodesk.Revit.UI import *\nfrom System.Collections.Generic import List\nimport System\nfrom System.Windows.Forms import (\n    Form, Label, TextBox, Button, ComboBox, \n    DialogResult, ListBox, SelectionMode, MessageBox\n)\n\n# Get the current Revit document\ndoc = __revit__.ActiveUIDocument.Document\nuidoc = __revit__.ActiveUIDocument\n\ndef get_text_note_types():\n    \"\"\"Get all text note types in the project\"\"\"\n    return FilteredElementCollector(doc).OfClass(TextNoteType).ToElements()\n\ndef get_all_fonts():\n    \"\"\"Get all available fonts in the project\"\"\"\n    text_element_types = get_text_note_types()\n    fonts = set()\n    \n    for text_type in text_element_types:\n        font_param = text_type.get_Parameter(BuiltInParameter.TEXT_FONT)\n        if font_param:\n            fonts.add(font_param.AsString())\n    \n    return sorted(list(fonts))\n\nclass FontChangeForm(Form):\n    def __init__(self, fonts):\n        self.Width = 500\n        self.Height = 300\n        self.Text = \"Font Change Tool\"\n        \n        # Current font selection\n        current_font_label = Label()\n        current_font_label.Text = \"Select Current Font:\"\n        current_font_label.Location = System.Drawing.Point(20, 20)\n        current_font_label.Width = 150\n        self.Controls.Add(current_font_label)\n        \n        self.current_font_combo = ComboBox()\n        self.current_font_combo.Location = System.Drawing.Point(170, 20)\n        self.current_font_combo.Width = 300\n        self.current_font_combo.Items.AddRange(fonts)\n        if fonts:\n            self.current_font_combo.SelectedIndex = 0\n        self.Controls.Add(self.current_font_combo)\n        \n        # New font selection\n        new_font_label = Label()\n        new_font_label.Text = \"Select New Font:\"\n        new_font_label.Location = System.Drawing.Point(20, 60)\n        new_font_label.Width = 150\n        self.Controls.Add(new_font_label)\n        \n        self.new_font_combo = ComboBox()\n        self.new_font_combo.Location = System.Drawing.Point(170, 60)\n        self.new_font_combo.Width = 300\n        self.new_font_combo.Items.AddRange(fonts)\n        if fonts:\n            self.new_font_combo.SelectedIndex = 0\n        self.Controls.Add(self.new_font_combo)\n        \n        # Update button\n        update_button = Button()\n        update_button.Text = \"Update Fonts\"\n        update_button.Location = System.Drawing.Point(170, 120)\n        update_button.Width = 140\n        update_button.Click += self.update_fonts\n        self.Controls.Add(update_button)\n        \n        # Cancel button\n        cancel_button = Button()\n        cancel_button.Text = \"Cancel\"\n        cancel_button.Location = System.Drawing.Point(320, 120)\n        cancel_button.Width = 140\n        cancel_button.Click += self.close_form\n        self.Controls.Add(cancel_button)\n    \n    def close_form(self, sender, event):\n        self.Close()\n    \n    def update_fonts(self, sender, event):\n        current_font = self.current_font_combo.SelectedItem\n        new_font = self.new_font_combo.SelectedItem\n        \n        if current_font == new_font:\n            MessageBox.Show(\"Current and new fonts are the same. Please select different fonts.\")\n            return\n        \n        try:\n            t = Transaction(doc, \"Change Fonts\")\n            t.Start()\n            \n            text_note_types = get_text_note_types()\n            count = 0\n            \n            for text",
			"description": "This Revit add-in allows users to change the font of existing text note types within the Revit document. It presents a form with combo boxes to select the current font to replace and the new font to use, then updates the font parameter of the selected text note types.",
			"likes": 0,
			"created_at": "2025-04-15T07:02:55.928027+00:00"
		},
		{
			"id": 123,
			"title": "Tie Rebar Spacing Constraint",
			"code": "i want to constraint a tie rebar to the next tie rebar by a sertain distanc",
			"description": "This describes the intent to constrain the spacing between tie rebars in a structural model. It aims to maintain a specific distance between consecutive tie rebars.",
			"likes": 0,
			"created_at": "2025-05-09T17:52:24.463446+00:00"
		},
		{
			"id": 32,
			"title": "Create a Simple Wall in Revit",
			"code": "import Autodesk\nfrom Autodesk.Revit.DB import *\nimport clr\nfrom System.Collections.Generic import List\n\n# Get the active document\ndoc = __revit__.ActiveUIDocument.Document\nuidoc = __revit__.ActiveUIDocument\n\n# Start a transaction\nt = Transaction(doc, \"Create Small Wall\")\nt.Start()\n\ntry:\n    # Get wall type\n    wall_types = FilteredElementCollector(doc).OfClass(WallType)\n    wall_type = None\n    for wt in wall_types:\n        if \"Basic Wall\" in wt.FamilyName:\n            wall_type = wt\n            break\n    \n    if wall_type is None:\n        wall_type = wall_types.FirstElement()\n    \n    # Create a line for the wall\n    pt1 = XYZ(0, 0, 0)\n    pt2 = XYZ(5, 0, 0)\n    line = Line.CreateBound(pt1, pt2)\n    \n    # Create the wall\n    level = FilteredElementCollector(doc).OfClass(Level).FirstElement()\n    height = 8.0\n    wall = Wall.Create(doc, line, wall_type.Id, level.Id, height, 0.0, False, False)\n    \n    t.Commit()\n    \nexcept Exception as e:\n    t.RollBack()\n    import traceback\n    print(traceback.format_exc())",
			"description": "This script creates a straight wall in the active Revit document. It retrieves a basic wall type, defines a line for the wall's location, and then uses the Wall.Create method to generate the wall, placing it on the first available level.",
			"likes": 0,
			"created_at": "2025-03-27T03:26:08.56624+00:00"
		},
		{
			"id": 19,
			"title": "Revit Dimension Creator",
			"code": "import clr\nclr.AddReference('RevitAPI')\nclr.AddReference('RevitAPIUI')\nfrom Autodesk.Revit.DB import *\nfrom Autodesk.Revit.UI import *\n\ndoc = __revit__.ActiveUIDocument.Document\nuidoc = __revit__.ActiveUIDocument\n\n# Collect all walls, doors, and windows\nwalls = FilteredElementCollector(doc).OfCategory(BuiltInCategory.OST_Walls).WhereElementIsNotElementType().ToElements()\ndoors = FilteredElementCollector(doc).OfCategory(BuiltInCategory.OST_Doors).WhereElementIsNotElementType().ToElements()\nwindows = FilteredElementCollector(doc).OfCategory(BuiltInCategory.OST_Windows).WhereElementIsNotElementType().ToElements()\n\nt = Transaction(doc, \"Create Dimensions\")\nt.Start()\n\n# Create dimensions for walls\nfor wall in walls:\n    loc = wall.Location\n    if isinstance(loc, LocationCurve):\n        curve = loc.Curve\n        p1 = curve.GetEndPoint(0)\n        p2 = curve.GetEndPoint(1)\n        line = Line.CreateBound(p1, p2)\n        ref_array = ReferenceArray()\n        ref_array.Append(wall.References[0])\n        ref_array.Append(wall.References[1])\n        try:\n            dim = doc.Create.NewDimension(doc.ActiveView, line, ref_array)\n        except:\n            continue\n\n# Create dimensions for doors and windows\nfor element in list(doors) + list(windows):\n    try:\n        host = element.Host\n        if isinstance(host, Wall):\n            face_ref = host.References[0]\n            opening_refs = element.References\n            ref_array = ReferenceArray()\n            ref_array.Append(face_ref)\n            ref_array.Append(opening_refs[0])\n            \n            bb = element.get_BoundingBox(doc.ActiveView)\n            p1 = XYZ(bb.Min.X, bb.Min.Y, bb.Min.Z)\n            p2 = XYZ(bb.Max.X, bb.Min.Y, bb.Min.Z)\n            line = Line.CreateBound(p1, p2)\n            \n            dim = doc.Create.NewDimension(doc.ActiveView, line, ref_array)\n    except:\n        continue\n\nt.Commit()",
			"description": "This script automates the creation of dimensions in a Revit document. It collects walls, doors, and windows and generates dimensions for them based on their geometry and location relative to walls, using the active view.",
			"likes": 0,
			"created_at": "2025-03-25T04:03:46.712246+00:00"
		},
		{
			"id": 22,
			"title": "Relocate Revit Project Based on CAD Import Coordinates",
			"code": "import clr\nimport Autodesk\nfrom Autodesk.Revit.DB import *\nfrom Autodesk.Revit.UI import *\nfrom System.Collections.Generic import List\n\ndoc = __revit__.ActiveUIDocument.Document\nuidoc = __revit__.ActiveUIDocument\n\n# Get all CAD imports in the project\ncollector = FilteredElementCollector(doc).OfClass(ImportInstance)\ncad_imports = list(collector)\n\nif not cad_imports:\n    TaskDialog.Show(\"Error\", \"No CAD imports found in the document.\")\nelse:\n    # Start a transaction\n    t = Transaction(doc, \"Relocate Project Based on CAD Coordinates\")\n    t.Start()\n    \n    try:\n        # Get the first CAD import's coordinate system\n        cad_import = cad_imports[0]\n        \n        # Get the transform from the CAD import\n        transform = cad_import.GetTotalTransform()\n        \n        # Get the project base point\n        collector = FilteredElementCollector(doc).OfCategory(BuiltInCategory.OST_ProjectBasePoint)\n        base_point = collector.FirstElement()\n        \n        if base_point:\n            # Get current position parameters\n            param_n = base_point.get_Parameter(BuiltInParameter.BASEPOINT_NORTHSOUTH_PARAM)\n            param_e = base_point.get_Parameter(BuiltInParameter.BASEPOINT_EASTWEST_PARAM)\n            param_elev = base_point.get_Parameter(BuiltInParameter.BASEPOINT_ELEVATION_PARAM)\n            \n            # Extract translation values from the transform\n            translation = transform.Origin\n            \n            # Set the project base point to match the CAD import origin\n            param_e.Set(translation.X)\n            param_n.Set(translation.Y)\n            param_elev.Set(translation.Z)\n            \n            TaskDialog.Show(\"Success\", \"Project relocated based on CAD import coordinates.\")\n        else:\n            TaskDialog.Show(\"Error\", \"Project base point not found.\")\n            \n        t.Commit()\n    except Exception as e:\n        t.RollBack()\n        TaskDialog.Show(\"Error\", \"Failed to relocate project: \" + str(e))",
			"description": "This script finds the first CAD import in a Revit project and relocates the project base point to match the CAD import's origin. It extracts the translation values from the CAD import's transform and applies them to the project base point's Easting, Northing, and Elevation parameters.",
			"likes": 0,
			"created_at": "2025-03-25T06:23:22.37865+00:00"
		},
		{
			"id": 56,
			"title": "Create Offset Room Boundaries in Revit",
			"code": "import clr\nfrom Autodesk.Revit.DB import *\nfrom Autodesk.Revit.DB.Architecture import Room\nfrom System.Collections.Generic import List\nimport math\n\ndoc = __revit__.ActiveUIDocument.Document\nuidoc = __revit__.ActiveUIDocument\nview = doc.ActiveView\n\n# Input room list (update as needed or use your existing room collection)\nrooms = FilteredElementCollector(doc).OfCategory(BuiltInCategory.OST_Rooms).WhereElementIsNotElementType().ToElements()\n\n# Offset value (150mm)\noffset_value = 150 / 304.8  # Convert mm to feet\n\n# Create transaction\nt = Transaction(doc, \"Create Room Boundaries with Offset\")\nt.Start()\n\n# Options for spatial boundary\noptions = SpatialElementBoundaryOptions()\noptions.SpatialElementBoundaryLocation = SpatialElementBoundaryLocation.Finish\n\n# Function to determine wall width\ndef get_wall_width(wall_id):\n    if wall_id.IntegerValue < 0:  # Not a real wall\n        return 0\n    \n    wall = doc.GetElement(wall_id)\n    if wall is None or not isinstance(wall, Wall):\n        return 0\n    \n    wall_type = wall.WallType\n    return wall_type.Width\n\n# Function to offset curve based on wall width\ndef offset_curve(curve, wall_width, normal_vector):\n    offset_distance = wall_width / 2 + offset_value\n    \n    # Make sure the normal vector is pointing towards the room\n    if normal_vector.DotProduct(XYZ(0, 0, 1)) < 0:\n        normal_vector = normal_vector.Negate()\n    \n    # Create offset vector\n    offset_vector = XYZ(normal_vector.X, normal_vector.Y, 0).Normalize().Multiply(offset_distance)\n    \n    # Transform curve\n    transform = Transform.CreateTranslation(offset_vector)\n    return curve.CreateTransformed(transform)\n\n# Process each room\nresult_curves_by_room = {}\n\nfor room in rooms:\n    if room.Area > 0:\n        boundary_segments = room.GetBoundarySegments(options)\n        offset_curves = []\n        \n        for segment_list in boundary_segments:\n            for segment in segment_list:\n                curve = segment.GetCurve()\n                element_id = segment.ElementId\n                \n                # Get the wall width\n                wall_width = get_wall_width(element_id)\n                \n                # Get normal vector (pointing inward to the room)\n                normal_vector = segment.GetNormal()\n                \n                # Offset the curve\n                offset_curve_result = offset_curve(curve, wall_width, normal_vector)\n                offset_curves.append(offset_curve_result)\n        \n        # Store results\n        result_curves_by_room[room.Id.IntegerValue] = offset_curves\n\nt.Commit()\n\n# Optional: Visualize the results by creating model curves\nt = Transaction(doc, \"Create Model Curves for Visualization\")\nt.Start()\n\nfor room_id, curves in result_curves_by_room.items():\n    for curve in curves:\n        if curve.Length > 0:\n            # Create model curve\n            mc = doc.Create.NewModelCurve(curve, SketchPlane.Create(doc, view.GenLevel.Id, XYZ(0, 0, 1)))\n\nt.Commit()",
			"description": "This code creates offset room boundaries in a Revit model. It iterates through each room, retrieves its boundary segments, offsets those segments based on wall width and a predefined offset value (150mm), and visualizes the offset boundaries using model curves.",
			"likes": 0,
			"created_at": "2025-04-06T15:31:35.367501+00:00"
		},
		{
			"id": 133,
			"title": "Automated Duct Creation in Revit",
			"code": "# Boilerplate imports\nimport clr\nclr.AddReference('RevitAPI')\nclr.AddReference('RevitAPIUI')\nclr.AddReference(\"System.Windows.Forms\")\nclr.AddReference(\"System.Drawing\")\n\nfrom Autodesk.Revit.DB import *\nfrom Autodesk.Revit.UI import *\nfrom Autodesk.Revit.UI.Selection import ObjectType, ISelectionFilter\n\nfrom System.Windows.Forms import (\n    Application, Form, Label, ComboBox, Button, DialogResult,\n    FormBorderStyle, GroupBox, RadioButton, TextBox, CheckBox\n)\nfrom System.Drawing import Point, Size\nimport System\n\n# --- Configuration ---\n# You can pre-set some default names if you like\nDEFAULT_SUPPLY_SYSTEM_NAME = \"Supply Air\"\nDEFAULT_RETURN_SYSTEM_NAME = \"Return Air\"\n# You can set a default duct offset from the level, in Revit internal units (feet)\nDEFAULT_DUCT_OFFSET = 8.0 # e.g., 8 feet above level elevation\n\n# --- Helper Functions ---\ndef get_all_duct_types(doc):\n    \"\"\"Returns a dictionary of DuctType names to their Ids.\"\"\"\n    collector = FilteredElementCollector(doc).OfClass(DuctType)\n    return {dt.Name: dt.Id for dt in collector}\n\ndef get_all_mep_system_types(doc, include_supply=True, include_return=True):\n    \"\"\"Returns a dictionary of MEPSystemType names to their Ids, filtered for HVAC.\"\"\"\n    collector = FilteredElementCollector(doc).OfClass(MEPSystemType)\n    system_types = {}\n    for st in collector:\n        # SystemClassification for HVAC systems:\n        # SupplyAir, ReturnAir, ExhaustAir, OtherAir\n        # We are interested in SupplyAir and ReturnAir\n        sys_class = st.SystemClassification\n        if include_supply and sys_class == MEPSystemClassification.SupplyAir:\n            system_types[st.Name + \" (Supply)\"] = st.Id\n        elif include_return and sys_class == MEPSystemClassification.ReturnAir:\n            system_types[st.Name + \" (Return)\"] = st.Id\n    return system_types\n\ndef get_all_levels(doc):\n    \"\"\"Returns a dictionary of Level names to their Ids.\"\"\"\n    collector = FilteredElementCollector(doc).OfClass(Level).WhereElementIsNotElementType()\n    return {l.Name: l.Id for l in sorted(list(collector), key=lambda x: x.Elevation)}\n\ndef get_primary_hvac_connector(element):\n    \"\"\"\n    Tries to find a suitable HVAC connector on an element.\n    Returns the first unconnected HVAC connector.\n    \"\"\"\n    if not element or not hasattr(element, \"MEPModel\") or element.MEPModel is None:\n        print(\"Element {} has no MEPModel.\".format(element.Id))\n        return None\n    if not hasattr(element.MEPModel, \"ConnectorManager\") or element.MEPModel.ConnectorManager is None:\n        print(\"Element {} has no ConnectorManager.\".format(element.Id))\n        return None\n        \n    connector_manager = element.MEPModel.ConnectorManager\n    if connector_manager.Connectors.IsEmpty:\n        print(\"Element {} has no connectors.\".format(element.Id))\n        return None\n\n    for connector in connector_manager.Connectors:\n        if connector.Domain == Domain.DomainHvac: # and not connector.IsConnected:\n            # For simplicity, we take the first HVAC connector.\n            # More robust logic might check FlowDirection, SystemType, etc.\n            return connector\n    print(\"No suitable HVAC connector found on element {}.\".format(element.Id))\n    return None\n\ndef find_duct_connector_near_point(duct, point, tolerance=0.1):\n    \"\"\"Finds a duct connector closest to a given point.\"\"\"\n    if not duct or not duct.ConnectorManager:\n        return None\n    \n    best_connector = None\n    min_dist_sq = tolerance * tolerance # Using squared distance for efficiency\n\n    for conn in duct.ConnectorManager.Connectors:\n        if conn.ConnectorType == ConnectorType.End: # Ducts have end connectors\n            dist_sq = conn.Origin.DistanceTo(point) ** 2\n            if dist_sq < min_dist_sq:\n                min_dist_sq = dist_sq\n                best_connector = conn\n    return best_connector\n\n# --- UI Form ---\nclass DuctCreationForm(Form):\n    def __init__(self, duct_types_dict, system_types_dict, levels_dict):\n        self.Text = \"Automate Duct Creation\"\n        self.FormBorderStyle = FormBorderStyle.FixedDialog\n        self.MaximizeBox = False\n        self.MinimizeBox = False\n        self.ClientSize = Size(400, 320) # Adjusted height\n\n        self.selected_duct_type_id = None\n        self.selected_system_type_id = None\n        self.selected_level_id = None\n        self.start_element_id = None\n        self.end_element_id = None\n        self.duct_offset_from_level = DEFAULT_DUCT_OFFSET # In feet\n\n        # Level Selection\n        lbl_level = Label()\n        lbl_level.Text = \"Select Level for Duct:\"\n        lbl_level.Location = Point(10, 10)\n        lbl_level.AutoSize = True\n        self.Controls.Add(lbl_level)\n\n        self.cb_level = ComboBox()\n        self.cb_level.Location = Point(10, 30)\n        self.cb_level.Size = Size(380, 21)\n        self.cb_level.DropDownStyle = ComboBoxStyle.DropDownList\n        for name, id_val in levels_dict.items():\n            self.cb_level.Items.Add(name)\n        if self.cb_level.Items.Count > 0:\n            self.cb_level.SelectedIndex = 0\n\n        # Duct Type Selection\n        lbl_duct_type = Label()\n        lbl_duct_type.Text = \"Select Duct Type:\"\n        lbl_duct_type.Location = Point(10, 60)\n        lbl_duct_type.AutoSize = True\n        self.Controls.Add(lbl_duct_type)\n\n        self.cb_duct_type = ComboBox()\n        self.cb_duct_type.Location = Point(10, 80)\n        self.cb_duct_type.Size = Size(380, 21)\n        self.cb_duct_type.DropDownStyle = ComboBoxStyle.DropDownList\n        for name, id_val in duct_types_dict.items():\n            self.cb_duct_type.Items.Add(name)\n        if self.cb_duct_type.Items.Count > 0:\n            self.cb_duct_type.SelectedIndex = 0\n        \n        # System Type Selection\n        lbl_system_type = Label()\n        lbl_system_type.Text = \"Select System Type:\"\n        lbl_system_type.Location = Point(10, 110)\n        lbl_system_type.AutoSize = True\n        self.Controls.Add(lbl_system_type)\n\n        self.cb_system_type = ComboBox()\n        self.cb_system_type.Location = Point(10, 130)\n        self.cb_system_type.Size = Size(380, 21)\n        self.cb_system_type.DropDownStyle = ComboBoxStyle.DropDownList\n        for name, id_val in system_types_dict.items():\n            self.cb_system_type.Items.Add(name)\n        if self.cb_system_type.Items.Count > 0:\n            # Try to pre-select Supply Air\n            supply_keys = [k for k in system_types_dict.keys() if \"supply\" in k.lower()]\n            if supply_keys:\n                self.cb_system_type.SelectedItem = supply_keys[0]\n            else:\n                self.cb_system_type.SelectedIndex = 0\n\n        # Duct Offset\n        lbl_offset = Label()\n        lbl_offset.Text = \"Duct Centerline Offset from Level (ft):\"\n        lbl_offset.Location = Point(10, 160)\n        lbl_offset.AutoSize = True\n        self.Controls.Add(lbl_offset)\n\n        self.txt_offset = TextBox()\n        self.txt_offset.Text = str(self.duct_offset_from_level)\n        self.txt_offset.Location = Point(10, 180)\n        self.txt_offset.Size = Size(100, 20)\n        self.Controls.Add(self.txt_offset)\n\n        # Buttons\n        self.btn_select_start = Button()\n        self.btn_select_start.Text = \"Select Start Element\"\n        self.btn_select_start.Location = Point(10, 220)\n        self.btn_select_start.Size = Size(185, 30)\n        self.btn_select_start.Click += self.select_start_element_click\n        self.Controls.Add(self.btn_select_start)\n        self.lbl_start_element = Label()\n        self.lbl_start_element.Text = \"Start: None\"\n        self.lbl_start_element.Location = Point(200, 225) # Adjusted Y\n        self.lbl_start_element.AutoSize = True\n        self.Controls.Add(self.lbl_start_element)\n\n\n        self.btn_select_end = Button()\n        self.btn_select_end.Text = \"Select End Element\"\n        self.btn_select_end.Location = Point(10, 255) # Adjusted Y\n        self.btn_select_end.Size = Size(185, 30)\n        self.btn_select_end.Click += self.select_end_element_click\n        self.Controls.Add(self.btn_select_end)\n        self.lbl_end_element = Label()\n        self.lbl_end_element.Text = \"End: None\"\n        self.lbl_end_element.Location = Point(200, 260) # Adjusted Y\n        self.lbl_end_element.AutoSize = True\n        self.Controls.Add(self.lbl_end_element)\n\n        self.btn_create = Button()\n        self.btn_create.Text = \"Create Duct\"\n        self.btn_create.Location = Point(10, 290) # Adjusted Y\n        self.btn_create.Size = Size(185, 30)\n        self.btn_create.DialogResult = DialogResult.OK\n        self.btn_create.Click += self.create_click\n        self.Controls.Add(self.btn_create)\n\n        self.btn_cancel = Button()\n        self.btn_cancel.Text = \"Cancel\"\n        self.btn_cancel.Location = Point(205, 290) # Adjusted Y\n        self.btn_cancel.Size = Size(185, 30)\n        self.btn_cancel.DialogResult = DialogResult.Cancel\n        self.Controls.Add(self.btn_cancel)\n        \n        self.CenterToParent()\n\n\n    def select_element(self, uidoc, prompt_message):\n        try:\n            self.Hide() # Hide form during selection\n            reference = uidoc.Selection.PickObject(ObjectType.Element, prompt_message)\n            self.Show() # Show form again\n            return doc.GetElement(reference.ElementId)\n        except Exception as e:\n            # This catches 'OperationCanceledException' if user presses Esc\n            print(\"Selection cancelled or failed: \" + str(e))\n            self.Show()\n            return None\n\n    def select_start_element_click(self, sender, args):\n        element = self.select_element(uidoc, \"Select the START air terminal or equipment.\")\n        if element:\n            self.start_element_id = element.Id\n            self.lbl_start_element.Text = \"Start: ID \" + str(element.Id.IntegerValue)\n        else:\n            self.start_element_id = None\n            self.lbl_start_element.Text = \"Start: None\"\n\n    def select_end_element_click(self, sender, args):\n        element = self.select_element(uidoc, \"Select the END air terminal or equipment.\")\n        if element:\n            self.end_element_id = element.Id\n            self.lbl_end_element.Text = \"End: ID \" + str(element.Id.IntegerValue)\n        else:\n            self.end_element_id = None\n            self.lbl_end_element.Text = \"End: None\"\n            \n    def create_click(self, sender, args):\n        if not self.start_element_id or not self.end_element_id:\n            TaskDialog.Show(\"Error\", \"Please select both start and end elements.\")\n            self.DialogResult = DialogResult.None # Prevent form from closing\n            return\n\n        if self.cb_level.SelectedItem:\n            self.selected_level_id = levels_dict[self.cb_level.SelectedItem.ToString()]\n        else:\n            TaskDialog.Show(\"Error\", \"Please select a level.\")\n            self.DialogResult = DialogResult.None\n            return\n            \n        if self.cb_duct_type.SelectedItem:\n            self.selected_duct_type_id = duct_types_dict[self.cb_duct_type.SelectedItem.ToString()]\n        else:\n            TaskDialog.Show(\"Error\", \"Please select a duct type.\")\n            self.DialogResult = DialogResult.None\n            return\n\n        if self.cb_system_type.SelectedItem:\n            self.selected_system_type_id = system_types_dict[self.cb_system_type.SelectedItem.ToString()]\n        else:\n            TaskDialog.Show(\"Error\", \"Please select a system type.\")\n            self.DialogResult = DialogResult.None\n            return\n        \n        try:\n            self.duct_offset_from_level = float(self.txt_offset.Text)\n        except ValueError:\n            TaskDialog.Show(\"Error\", \"Invalid duct offset. Please enter a number.\")\n            self.DialogResult = DialogResult.None\n            return\n\n        # If all checks pass, DialogResult remains OK and form will close\n\n# --- Main Script Execution ---\nif __name__ == '__main__':\n    # Get Revit document and UIDocument\n    doc = __revit__.ActiveUIDocument.Document\n    uidoc = __revit__.ActiveUIDocument\n\n    # Fetch data for UI\n    duct_types_dict = get_all_duct_types(doc)\n    system_types_dict = get_all_mep_system_types(doc)\n    levels_dict = get_all_levels(doc)\n\n    if not duct_types_dict:\n        TaskDialog.Show(\"Error\", \"No duct types found in the project.\")\n        # Exit or handle error\n    elif not system_types_dict:\n        TaskDialog.Show(\"Error\", \"No HVAC system types (Supply/Return) found in the project.\")\n        # Exit or handle error\n    elif not levels_dict:\n        TaskDialog.Show(\"Error\", \"No levels found in the project.\")\n        # Exit or handle error\n    else:\n        form = DuctCreationForm(duct_types_dict, system_types_dict, levels_dict)\n        Application.EnableVisualStyles() # Optional: makes UI look more modern\n\n        if form.ShowDialog() == DialogResult.OK:\n            start_element = doc.GetElement(form.start_element_id)\n            end_element = doc.GetElement(form.end_element_id)\n            level_id = form.selected_level_id\n            duct_type_id = form.selected_duct_type_id\n            system_type_id = form.selected_system_type_id\n            duct_offset_input = form.duct_offset_from_level # This is in feet from UI\n\n            if not start_element or not end_element:\n                TaskDialog.Show(\"Error\", \"Start or end element not found (this shouldn't happen).\")\n            else:\n                # Get connectors\n                connector_start = get_primary_hvac_connector(start_element)\n                connector_end = get_primary_hvac_connector(end_element)\n\n                if not connector_start:\n                    TaskDialog.Show(\"Error\", \"Could not find a suitable HVAC connector on the start element.\")\n                elif not connector_end:\n                    TaskDialog.Show(\"Error\", \"Could not find a suitable HVAC connector on the end element.\")\n                else:\n                    # Start transaction\n                    t = Transaction(doc, \"Create Automated Duct\")\n                    try:\n                        t.Start()\n\n                        # Determine duct points\n                        # Use connector Z for start/end points to align better,\n                        # but force X,Y to be on the same plane based on level + offset\n                        level_element = doc.GetElement(level_id)\n                        level_elevation = level_element.Elevation\n                        \n                        # Convert user offset (feet) to internal units (feet) - already in feet\n                        # If user input was mm, you'd do: duct_offset_internal = UnitUtils.ConvertToInternalUnits(duct_offset_input, DisplayUnitType.DUT_MILLIMETERS)\n                        duct_centerline_z = level_elevation + duct_offset_input\n\n                        point_start_original = connector_start.Origin\n                        point_end_original = connector_end.Origin\n                        \n                        # Create points for duct creation at the specified Z elevation\n                        point_start = XYZ(point_start_original.X, point_start_original.Y, duct_centerline_z)\n                        point_end = XYZ(point_end_original.X, point_end_original.Y, duct_centerline_z)\n\n                        # Create the duct\n                        # Duct.Create(doc, systemTypeId, ductTypeId, levelId, startPoint, endPoint)\n                        new_duct = Mechanical.Duct.Create(doc, system_type_id, duct_type_id, level_id, point_start, point_end)\n                        \n                        if not new_duct:\n                            TaskDialog.Show(\"Error\", \"Failed to create duct element.\")\n                            t.RollBack()\n                        else:\n                            # Set duct offset (optional, if Duct.Create doesn't use it or if you want to be explicit)\n                            # param_offset = new_duct.get_Parameter(BuiltInParameter.RBS_OFFSET_PARAM)\n                            # if param_offset and not param_offset.IsReadOnly:\n                            #    param_offset.Set(duct_centerline_z - level_elevation) # Offset is relative to level\n\n                            # Attempt to connect the duct to the elements\n                            # Need to find the connectors on the newly created duct\n                            new_duct_conn_manager = new_duct.ConnectorManager\n                            \n                            duct_connector_at_start_pt = find_duct_connector_near_point(new_duct, point_start)\n                            duct_connector_at_end_pt   = find_duct_connector_near_point(new_duct, point_end)\n\n                            connection_success_count = 0\n                            if duct_connector_at_start_pt and connector_start:\n                                try:\n                                    if not duct_connector_at_start_pt.IsConnected and not connector_start.IsConnected:\n                                        duct_connector_at_start_pt.ConnectTo(connector_start)\n                                        connection_success_count +=1\n                                        print(\"Connected duct start to start element.\")\n                                    elif duct_connector_at_start_pt.IsConnectedTo(connector_start):\n                                        connection_success_count +=1\n                                        print(\"Duct start already connected to start element.\")\n                                    else:\n                                        print(\"Could not connect duct start: one or both connectors already connected to something else.\")\n                                except Exception as ex_conn_start:\n                                    print(\"Error connecting duct start: {}\".format(str(ex_conn_start)))\n                            else:\n                                print(\"Could not find duct's start connector or element's start connector.\")\n\n                            if duct_connector_at_end_pt and connector_end:\n                                try:\n                                    if not duct_connector_at_end_pt.IsConnected and not connector_end.IsConnected:\n                                        duct_connector_at_end_pt.ConnectTo(connector_end)\n                                        connection_success_count +=1\n                                        print(\"Connected duct end to end element.\")\n                                    elif duct_connector_at_end_pt.IsConnectedTo(connector_end):\n                                        connection_success_count +=1\n                                        print(\"Duct end already connected to end element.\")\n                                    else:\n                                        print(\"Could not connect duct end: one or both connectors already connected to something else.\")\n                                except Exception as ex_conn_end:\n                                    print(\"Error connecting duct end: {}\".format(str(ex_conn_end)))\n                            else:\n                                print(\"Could not find duct's end connector or element's end connector.\")\n\n                            if connection_success_count > 0:\n                                TaskDialog.Show(\"Success\", \"Duct created. {} connections made.\".format(connection_success_count))\n                            else:\n                                TaskDialog.Show(\"Warning\", \"Duct created, but failed to connect to elements. Manual connection might be needed.\")\n                            \n                            t.Commit()\n                    except Exception as e:\n                        t.RollBack()\n                        error_message = \"An error occurred: \" + str(e)\n                        print(error_message)\n                        TaskDialog.Show(\"Error\", error_message)\n        else:\n            print(\"Operation cancelled by user.\")",
			"description": "This code creates a Revit add-in that automates duct creation between two selected elements. The add-in uses a Windows Form to allow users to specify the level, duct type, system type, and offset, and then creates and connects a duct between the selected elements' HVAC connectors.",
			"likes": 0,
			"created_at": "2025-05-14T15:34:55.954635+00:00"
		},
		{
			"id": 73,
			"title": "Revit Text Font Changer",
			"code": "# Import necessary libraries\nimport clr\nfrom Autodesk.Revit.DB import *\nfrom Autodesk.Revit.UI import *\nfrom System.Collections.Generic import List\nimport System\nfrom System.Windows.Forms import (\n    Form, Label, TextBox, Button, ComboBox, \n    DialogResult, ListBox, SelectionMode, MessageBox\n)\n\n# Get the current Revit document\ndoc = __revit__.ActiveUIDocument.Document\nuidoc = __revit__.ActiveUIDocument\n\ndef get_text_note_types():\n    \"\"\"Get all text note types in the project\"\"\"\n    return FilteredElementCollector(doc).OfClass(TextNoteType).ToElements()\n\ndef get_all_fonts():\n    \"\"\"Get all available fonts in the project\"\"\"\n    text_element_types = get_text_note_types()\n    fonts = set()\n    \n    for text_type in text_element_types:\n        font_param = text_type.get_Parameter(BuiltInParameter.TEXT_FONT)\n        if font_param:\n            fonts.add(font_param.AsString())\n    \n    return sorted(list(fonts))\n\nclass FontChangeForm(Form):\n    def __init__(self, fonts):\n        self.Width = 500\n        self.Height = 300\n        self.Text = \"Font Change Tool\"\n        \n        # Current font selection\n        current_font_label = Label()\n        current_font_label.Text = \"Select Current Font:\"\n        current_font_label.Location = System.Drawing.Point(20, 20)\n        current_font_label.Width = 150\n        self.Controls.Add(current_font_label)\n        \n        self.current_font_combo = ComboBox()\n        self.current_font_combo.Location = System.Drawing.Point(170, 20)\n        self.current_font_combo.Width = 300\n        self.current_font_combo.Items.AddRange(fonts)\n        if fonts:\n            self.current_font_combo.SelectedIndex = 0\n        self.Controls.Add(self.current_font_combo)\n        \n        # New font selection\n        new_font_label = Label()\n        new_font_label.Text = \"Select New Font:\"\n        new_font_label.Location = System.Drawing.Point(20, 60)\n        new_font_label.Width = 150\n        self.Controls.Add(new_font_label)\n        \n        self.new_font_combo = ComboBox()\n        self.new_font_combo.Location = System.Drawing.Point(170, 60)\n        self.new_font_combo.Width = 300\n        self.new_font_combo.Items.AddRange(fonts)\n        if fonts:\n            self.new_font_combo.SelectedIndex = 0\n        self.Controls.Add(self.new_font_combo)\n        \n        # Update button\n        update_button = Button()\n        update_button.Text = \"Update Fonts\"\n        update_button.Location = System.Drawing.Point(170, 120)\n        update_button.Width = 140\n        update_button.Click += self.update_fonts\n        self.Controls.Add(update_button)\n        \n        # Cancel button\n        cancel_button = Button()\n        cancel_button.Text = \"Cancel\"\n        cancel_button.Location = System.Drawing.Point(320, 120)\n        cancel_button.Width = 140\n        cancel_button.Click += self.close_form\n        self.Controls.Add(cancel_button)\n    \n    def close_form(self, sender, event):\n        self.Close()\n    \n    def update_fonts(self, sender, event):\n        current_font = self.current_font_combo.SelectedItem\n        new_font = self.new_font_combo.SelectedItem\n        \n        if current_font == new_font:\n            MessageBox.Show(\"Current and new fonts are the same. Please select different fonts.\")\n            return\n        \n        try:\n            t = Transaction(doc, \"Change Fonts\")\n            t.Start()\n            \n            text_note_types = get_text_note_types()\n            count = 0\n            \n            for text",
			"description": "This code provides a tool to change the font of TextNoteTypes within a Revit project. It creates a form with combo boxes to select the current and new font, then updates the font parameter of the selected TextNoteTypes.",
			"likes": 0,
			"created_at": "2025-04-15T07:02:42.185193+00:00"
		},
		{
			"id": 61,
			"title": "Revit Python: Create Walls in Rectangular Formation",
			"code": "import clr\nimport Autodesk.Revit.DB as DB\nfrom Autodesk.Revit.DB import *\nfrom Autodesk.Revit.UI import *\n\n# Get the current document\ndoc = __revit__.ActiveUIDocument.Document\nuidoc = __revit__.ActiveUIDocument\n\n# Create transaction\nt = Transaction(doc, \"Create Wall\")\nt.Start()\n\ntry:\n    # Create wall points (rectangular floor plan)\n    point1 = XYZ(0, 0, 0)\n    point2 = XYZ(20, 0, 0)\n    point3 = XYZ(20, 30, 0)\n    point4 = XYZ(0, 30, 0)\n    \n    # Get default wall type\n    wall_types = FilteredElementCollector(doc).OfClass(WallType)\n    wall_type = wall_types.FirstElement()\n    \n    # Get default level\n    levels = FilteredElementCollector(doc).OfClass(Level)\n    level = levels.FirstElement()\n    \n    # Define wall height\n    height = 10.0\n    \n    # Create walls\n    wall1 = Wall.Create(doc, Line.CreateBound(point1, point2), wall_type.Id, level.Id, height, 0.0, False, False)\n    wall2 = Wall.Create(doc, Line.CreateBound(point2, point3), wall_type.Id, level.Id, height, 0.0, False, False)\n    wall3 = Wall.Create(doc, Line.CreateBound(point3, point4), wall_type.Id, level.Id, height, 0.0, False, False)\n    wall4 = Wall.Create(doc, Line.CreateBound(point4, point1), wall_type.Id, level.Id, height, 0.0, False, False)\n    \n    t.Commit()\n    TaskDialog.Show(\"Success\", \"Walls created successfully\")\n    \nexcept Exception as e:\n    t.RollBack()\n    TaskDialog.Show(\"Error\", \"Failed to create walls: {}\".format(str(e)))",
			"description": "This Revit Python script creates four walls forming a rectangle on the default level of the current document. It uses the default wall type and a specified height for the walls, handling potential errors with a rollback mechanism.",
			"likes": 0,
			"created_at": "2025-04-08T06:23:16.058374+00:00"
		},
		{
			"id": 129,
			"title": "Revit Python: Create Manhole with Cover and Bedding",
			"code": "import Autodesk.Revit.DB as DB\nfrom Autodesk.Revit.DB import Transaction, FilteredElementCollector, BuiltInCategory, ElementId, XYZ\nimport System\n\nuidoc = __revit__.ActiveUIDocument\ndoc = uidoc.Document\n\n# Function to create manhole with thickness 20cm, cover and bedding\ndef create_manhole():\n    # Start transaction\n    t = Transaction(doc, \"Create Manhole\")\n    t.Start()\n    \n    try:\n        # Get active view\n        active_view = doc.ActiveView\n        \n        # Create manhole base (cylinder)\n        base_radius = 0.5  # 0.5m radius\n        base_height = 0.4  # 0.4m height\n        \n        # Thickness of the wall (20cm = 0.2m)\n        wall_thickness = 0.2\n        \n        # Inner radius\n        inner_radius = base_radius - wall_thickness\n        \n        # Create outer cylinder for the manhole\n        outer_circle = DB.Arc.Create(XYZ(0, 0, 0), base_radius, 0, 2 * 3.14159)\n        outer_profile = doc.FamilyCreate.NewRevolutionForm(True, outer_circle, DB.Line.CreateBound(XYZ(0, 0, 0), XYZ(0, 0, 1)), 0, base_height)\n        \n        # Create inner cylinder (void) for the manhole\n        inner_circle = DB.Arc.Create(XYZ(0, 0, 0), inner_radius, 0, 2 * 3.14159)\n        inner_profile = doc.FamilyCreate.NewRevolutionForm(False, inner_circle, DB.Line.CreateBound(XYZ(0, 0, 0), XYZ(0, 0, 1)), 0, base_height)\n        \n        # Create manhole cover (cylinder)\n        cover_height = 0.1  # 10cm thick cover\n        cover_circle = DB.Arc.Create(XYZ(0, 0, base_height), base_radius, 0, 2 * 3.14159)\n        cover_profile = doc.FamilyCreate.NewRevolutionForm(True, cover_circle, DB.Line.CreateBound(XYZ(0, 0, base_height), XYZ(0, 0, base_height + 1)), 0, cover_height)\n        \n        # Create bedding (cylinder below the manhole)\n        bedding_height = 0.15  # 15cm thick bedding\n        bedding_circle = DB.Arc.Create(XYZ(0, 0, -bedding_height), base_radius + 0.1, 0, 2 * 3.14159)\n        bedding_profile = doc.FamilyCreate.NewRevolutionForm(True, bedding_circle, DB.Line.CreateBound(XYZ(0, 0, -bedding_height), XYZ(0, 0, 0)), 0, bedding_height)\n        \n        # Set materials\n        # (Note: in actual implementation, you would need to retrieve material IDs from the project)\n        \n        # Success message\n        print(\"Manhole with 20cm wall thickness, cover and bedding created successfully\")\n        \n    except Exception as e:\n        print(\"Error creating manhole: {}\".format(e))\n        t.RollBack()\n        return\n    \n    # Commit the transaction\n    t.Commit()\n\n# Execute the function\ncreate_manhole()",
			"description": "This script creates a cylindrical manhole within a Revit document. It generates the manhole base, a void to create the wall thickness, a cover on top, and a bedding layer at the bottom using Revit's API.",
			"likes": 0,
			"created_at": "2025-05-13T15:28:23.046278+00:00"
		},
		{
			"id": 89,
			"title": "Cancels beam attachment to elements at ends",
			"code": "      ",
			"description": "This code cancels the connection of beams to structural elements at their ends. It effectively disconnects beams from any elements they are currently attached to at the beam's start and end points.",
			"likes": 0,
			"created_at": "2025-04-22T13:22:32.584546+00:00"
		},
		{
			"id": 105,
			"title": "Clash Navigator for pyRevit",
			"code": "# -*- coding: utf-8 -*-\n\"\"\"Clash Navigator for pyRevit (Minimal Version).\n\nProvides tools to navigate and manage clashes detected in Navisworks.\n\"\"\"\n__title__ = 'Clash\\nNavigator'\n__doc__ = 'Navigate and manage clashes detected in Navisworks'\n__author__ = 'Your Name'\n\nimport os\nimport xml.etree.ElementTree as ET\nimport sys\nfrom collections import defaultdict, namedtuple\n\nfrom pyrevit import script\nfrom pyrevit import revit, DB\nimport rpw\nfrom rpw.ui.forms import select_file, TextInput\n\n# Define data structures\nClashTest = namedtuple('ClashTest', ['name', 'clashes'])\nClashItem = namedtuple('ClashItem', ['id', 'name', 'point', 'distance', 'status', \n                                      'item1_id', 'item2_id', 'item1_name', \n                                      'item2_name', 'image_path'])\n\n# Status options for clashes\nCLASH_STATUSES = ['New', 'Active', 'Reviewed', 'Approved', 'Resolved', 'Ignored']\n\n# Main class for the extension\nclass ClashNavigatorApp:\n    def __init__(self):\n        self.clash_tests = []\n        self.current_test = None\n        self.current_clash = None\n        self.output = script.get_output()\n        self.doc = revit.doc\n        \n    def load_clash_report(self, file_path):\n        \"\"\"Load clash data from an XML file exported from Navisworks.\"\"\"\n        try:\n            tree = ET.parse(file_path)\n            root = tree.getroot()\n            \n            # Parse the XML file structure based on Navisworks clash report format\n            self.clash_tests = []\n            for test_elem in root.findall(\".//batchtest\"):\n                test_name = test_elem.get('name', 'Unnamed Test')\n                clashes = []\n                \n                for clash_elem in test_elem.findall(\".//clashresult\"):\n                    clash_id = clash_elem.get('id', 'Unknown')\n                    name = clash_elem.get('name', 'Clash ' + str(clash_id))\n                    status = clash_elem.get('status', 'New')\n                    \n                    # Get clash point coordinates\n                    point_elem = clash_elem.find('.//clashpoint')\n                    if point_elem is not None:\n                        x = float(point_elem.get('x', '0'))\n                        y = float(point_elem.get('y', '0'))\n                        z = float(point_elem.get('z', '0'))\n                        point = DB.XYZ(x, y, z)\n                    else:\n                        point = DB.XYZ(0, 0, 0)\n                    \n                    # Get distance\n                    distance_elem = clash_elem.find('.//distance')\n                    distance = float(distance_elem.text) if distance_elem is not None else 0.0\n                    \n                    # Get items involved in clash\n                    item1_elem = clash_elem.find('.//clashobject[1]')\n                    item2_elem = clash_elem.find('.//clashobject[2]')\n                    \n                    item1_id = item1_elem.get('objectid', 'Unknown') if item1_elem is not None else 'Unknown'\n                    item2_id = item2_elem.get('objectid', 'Unknown') if item2_elem is not None else 'Unknown'\n                    \n                    item1_name = item1_elem.get('name', 'Unknown') if item1_elem is not None else 'Unknown'\n                    item2_name = item2_elem.get('name', 'Unknown') if item2_elem is not None else 'Unknown'\n                    \n                    # Get image path if available\n                    image_elem = clash_elem.find('.//image')\n                    image_path = image_elem.text if image_elem is not None else None\n                    \n                    #",
			"description": "This code parses a Navisworks clash report XML file and extracts clash data. It organizes the data into clash tests and individual clashes, storing information like IDs, names, coordinates, distances, statuses, and involved elements.",
			"likes": 0,
			"created_at": "2025-04-27T04:50:19.852103+00:00"
		},
		{
			"id": 86,
			"title": "Create Walls from Model Lines in Revit",
			"code": "import clr\nimport System\n\nfrom Autodesk.Revit.DB import *\nfrom Autodesk.Revit.UI import *\nfrom System.Collections.Generic import List\n\n# Get the current document and create a transaction\ndoc = __revit__.ActiveUIDocument.Document\nuidoc = __revit__.ActiveUIDocument\n\n# Collect all model lines in the document\ncollector = FilteredElementCollector(doc).OfClass(CurveElement)\nmodel_lines = [elem for elem in collector if elem.Category.Name == \"Model Lines\"]\n\n# Get the default wall type\nwall_types = FilteredElementCollector(doc).OfClass(WallType)\ndefault_wall_type = wall_types.FirstElement()\n\n# Start a transaction\ntransaction = Transaction(doc, \"Create Walls from Model Lines\")\ntransaction.Start()\n\ntry:\n    # Create walls from each model line\n    for line in model_lines:\n        curve = line.GeometryCurve\n        \n        # Skip non-linear curves (can be expanded to handle arcs if needed)\n        if not isinstance(curve, Line):\n            continue\n            \n        # Create wall by curve\n        level = FilteredElementCollector(doc).OfClass(Level).FirstElement()\n        wall_height = 10.0  # Default height in feet\n        \n        # Create the wall\n        Wall.Create(\n            doc,\n            curve,\n            default_wall_type.Id,\n            level.Id,\n            wall_height,\n            0.0,  # Offset\n            False,  # Flip\n            True   # Structural\n        )\n    \n    transaction.Commit()\n    TaskDialog.Show(\"Success\", f\"Created {len(model_lines)} walls from model lines\")\n    \nexcept Exception as e:\n    transaction.RollBack()\n    TaskDialog.Show(\"Error\", f\"Failed to create walls: {str(e)}\")",
			"description": "This script creates walls in a Revit document based on existing model lines. It iterates through all model lines, converts each linear model line into a wall using the default wall type, and handles potential errors by rolling back the transaction.",
			"likes": 0,
			"created_at": "2025-04-22T03:43:59.838303+00:00"
		},
		{
			"id": 97,
			"title": "Duct Support Placement",
			"code": "import clr\nimport Autodesk\nfrom Autodesk.Revit.DB import *\nfrom Autodesk.Revit.DB.Mechanical import Duct\nfrom Autodesk.Revit.DB.Structure import StructuralType\nimport System\nfrom System import Array\nfrom System.Collections.Generic import List\nimport math\nimport RevitServices\nfrom RevitServices.Persistence import DocumentManager\nfrom RevitServices.Transactions import TransactionManager\n\n# Get current document\ndoc = DocumentManager.Instance.CurrentDBDocument\n\n# Define parameters\nSUPPORT_SPACING = 8.0  # Spacing in feet between supports\nRECT_SUPPORT_FAMILY_NAME = \"Duct Support - Rectangular\"\nROUND_SUPPORT_FAMILY_NAME = \"Duct Support - Round\"\nSUPPORT_TYPE_NAME = \"Standard\"\nMAX_DISTANCE_TO_LINKED_ELEMENT = 20.0  # Maximum distance to search for linked elements (feet)\n\n# Get all ducts in the current document\nducts = FilteredElementCollector(doc).OfClass(Duct).ToElements()\n\n# Get all linked models\nlinked_docs = FilteredElementCollector(doc).OfClass(RevitLinkInstance).ToElements()\n\n# Start transaction\nTransactionManager.Instance.EnsureInTransaction(doc)\n\n# Get the support family symbols\nrect_support_symbol = None\nround_support_symbol = None\n\nfor family_symbol in FilteredElementCollector(doc).OfClass(FamilySymbol):\n    family_name = family_symbol.Family.Name\n    if family_name == RECT_SUPPORT_FAMILY_NAME and family_symbol.Name == SUPPORT_TYPE_NAME:\n        rect_support_symbol = family_symbol\n    elif family_name == ROUND_SUPPORT_FAMILY_NAME and family_symbol.Name == SUPPORT_TYPE_NAME:\n        round_support_symbol = family_symbol\n    \n    if rect_support_symbol and round_support_symbol:\n        break\n\nif rect_support_symbol is None or round_support_symbol is None:\n    raise Exception(\"One or both support families not found in project\")\n\n# Make sure the symbols are active\nif not rect_support_symbol.IsActive:\n    rect_support_symbol.Activate()\nif not round_support_symbol.IsActive:\n    round_support_symbol.Activate()\n\n# Process each duct\nfor duct in ducts:\n    # Get duct curve\n    curve = duct.Location.Curve\n    \n    # Get duct length\n    length = curve.Length\n    \n    # Determine if duct is rectangular or round\n    duct_shape = duct.DuctType.Shape\n    is_rectangular = duct_shape == ConnectorProfileType.Rectangular\n    \n    # Get duct dimensions\n    if is_rectangular:\n        width = duct.get_Parameter(BuiltInParameter.RBS_DUCT_WIDTH_PARAM).AsDouble()\n        height = duct.get_Parameter(BuiltInParameter.RBS_DUCT_HEIGHT_PARAM).AsDouble()\n        support_symbol = rect_support_symbol\n    else:\n        diameter = duct.get_Parameter(BuiltInParameter.RBS_DUCT_DIAMETER_PARAM).AsDouble()\n        support_symbol = round_support_symbol\n    \n    # Calculate number of supports\n    num_supports = int(length / (SUPPORT_SPACING * 0.3048)) + 1\n    \n    if num_supports <= 1:\n        # Place at least one support in the middle\n        num_supports = 1\n    \n    # Place supports along the duct\n    for i in range(num_supports):\n        if num_supports == 1:\n            # Place in the middle\n            parameter = 0.5\n        else:\n            # Distribute evenly\n            parameter = float(i) / (num_supports - 1)\n        \n        # Get point on curve\n        point = curve.Evaluate(parameter, True)\n        \n        # Get curve direction at point\n        tangent = curve.ComputeDerivatives(parameter, True).BasisX.Normalize()\n        \n        # Calculate rotation\n        direction_z = XYZ(0, 0, ",
			"description": "This script automatically places duct supports along ducts in a Revit model based on a specified spacing. It distinguishes between rectangular and round ducts, selects the appropriate support family, calculates the number of supports required, and places them evenly along the duct's length.",
			"likes": 0,
			"created_at": "2025-04-24T20:41:40.23978+00:00"
		},
		{
			"id": 139,
			"title": "Revit Element Center of Gravity Calculator",
			"code": "import clr\nimport math\nfrom Autodesk.Revit.DB import *\nfrom Autodesk.Revit.UI import *\nfrom Autodesk.Revit.UI.Selection import *\nfrom System.Collections.Generic import List\n\n# This script calculates the center of gravity for a selected element\n\ndoc = __revit__.ActiveUIDocument.Document\nuidoc = __revit__.ActiveUIDocument\n\ntry:\n    # Prompt the user to select an element\n    selection = uidoc.Selection.PickObject(ObjectType.Element, \"Select an element to find its center of gravity\")\n    element = doc.GetElement(selection.ElementId)\n    \n    # Check if the element has a solid geometry\n    geomOptions = Options()\n    geomOptions.ComputeReferences = True\n    geomOptions.DetailLevel = ViewDetailLevel.Fine\n    \n    geomElem = element.get_Geometry(geomOptions)\n    \n    if geomElem is None:\n        TaskDialog.Show(\"Error\", \"Selected element does not have geometry.\")\n        raise Exception(\"No geometry found\")\n    \n    # Variables to accumulate values\n    total_volume = 0\n    weighted_x = 0\n    weighted_y = 0\n    weighted_z = 0\n    \n    # Process all solids in the geometry\n    for geomObj in geomElem:\n        # Handle instances (for family instances)\n        if isinstance(geomObj, GeometryInstance):\n            instance_geom = geomObj.GetInstanceGeometry()\n            for instance_obj in instance_geom:\n                if isinstance(instance_obj, Solid) and instance_obj.Volume > 0:\n                    solid = instance_obj\n                    volume = solid.Volume\n                    centroid = solid.ComputeCentroid()\n                    \n                    # Accumulate weighted coordinates\n                    weighted_x += centroid.X * volume\n                    weighted_y += centroid.Y * volume\n                    weighted_z += centroid.Z * volume\n                    total_volume += volume\n        \n        # Handle direct solids\n        elif isinstance(geomObj, Solid) and geomObj.Volume > 0:\n            solid = geomObj\n            volume = solid.Volume\n            centroid = solid.ComputeCentroid()\n            \n            # Accumulate weighted coordinates\n            weighted_x += centroid.X * volume\n            weighted_y += centroid.Y * volume\n            weighted_z += centroid.Z * volume\n            total_volume += volume\n    \n    if total_volume > 0:\n        # Calculate center of gravity\n        cog_x = weighted_x / total_volume\n        cog_y = weighted_y / total_volume\n        cog_z = weighted_z / total_volume\n        \n        # Create a result point\n        center_of_gravity = XYZ(cog_x, cog_y, cog_z)\n        \n        # Display the result\n        result_text = \"Center of Gravity:\\n\"\n        result_text += f\"X: {center_of_gravity.X:.4f} ft\\n\"\n        result_text += f\"Y: {center_of_gravity.Y:.4f} ft\\n\"\n        result_text += f\"Z: {center_of_gravity.Z:.4f} ft\\n\"\n        result_text += f\"Total Volume: {total_volume:.4f} cubic ft\"\n        \n        TaskDialog.Show(\"Center of Gravity\", result_text)\n    else:\n        TaskDialog.Show(\"Error\", \"No valid solid geometry found in the selected element.\")\n\nexcept Exception as e:\n    # Handle any exceptions\n    if \"operation cancelled\" not in str(e).lower():\n        TaskDialog.Show(\"Error\", str(e))",
			"description": "This script calculates the center of gravity (COG) of a selected element in Revit. It iterates through the element's geometry, computes the volume and centroid of each solid, and then calculates the weighted average to determine the COG.",
			"likes": 0,
			"created_at": "2025-05-16T18:59:01.954497+00:00"
		},
		{
			"id": 60,
			"title": "Change Wall Thickness of Specific Walls in Revit",
			"code": "using System;\nusing System.Linq;\nusing Autodesk.Revit.DB;\nusing Autodesk.Revit.UI;\nusing Autodesk.Revit.Attributes;\nusing Autodesk.Revit.UI.Selection;\n\n[Transaction(TransactionMode.Manual)]\npublic class ChangeWallThickness : IExternalCommand\n{\n    public Result Execute(ExternalCommandData commandData, ref string message, ElementSet elements)\n    {\n        UIDocument uidoc = commandData.Application.ActiveUIDocument;\n        Document doc = uidoc.Document;\n\n        using (Transaction tx = new Transaction(doc, \"Change Wall Thickness\"))\n        {\n            tx.Start();\n\n            // Lc tt c tng trong model\n            FilteredElementCollector collector = new FilteredElementCollector(doc)\n                .OfClass(typeof(Wall));\n\n            foreach (Wall wall in collector.Cast<Wall>())\n            {\n                WallType wallType = doc.GetElement(wall.GetTypeId()) as WallType;\n                CompoundStructure structure = wallType.GetCompoundStructure();\n\n                if (structure != null)\n                {\n                    double thickness = structure.GetWidth(); // Ly  dy tng (n v feet)\n                    double targetThickness = UnitUtils.ConvertToInternalUnits(0.1, DisplayUnitType.DUT_METERS); // 100mm -> feet\n                    double newThickness = UnitUtils.ConvertToInternalUnits(0.2, DisplayUnitType.DUT_METERS); // 200mm -> feet\n\n                    if (Math.Abs(thickness - targetThickness) < 0.001) // So snh vi sai s nh\n                    {\n                        structure.SetWidth(newThickness); // i thnh 200mm\n                        wallType.SetCompoundStructure(structure);\n                    }\n                }\n            }\n\n            tx.Commit();\n        }\n\n        return Result.Succeeded;\n    }\n}",
			"description": "This Revit add-in changes the thickness of walls that have a specific width (100mm) to a new width (200mm). It iterates through all walls in the model, retrieves their compound structure, and modifies the width if the thickness matches the target value.",
			"likes": 0,
			"created_at": "2025-04-08T06:22:03.027918+00:00"
		},
		{
			"id": 68,
			"title": "Revit Python Script: Create Custom Print Set",
			"code": "import clr\nimport System\nfrom Autodesk.Revit.DB import *\nfrom Autodesk.Revit.UI import *\nfrom System.Collections.Generic import List\n\ndoc = __revit__.ActiveUIDocument.Document\nuidoc = __revit__.ActiveUIDocument\n\n# Collect all sheets in the project\ncollector = FilteredElementCollector(doc).OfClass(ViewSheet)\nall_sheets = collector.ToElements()\n\n# Create a dictionary to store sheets by number\nsheets_by_number = {}\nfor sheet in all_sheets:\n    sheet_number = sheet.SheetNumber\n    sheets_by_number[sheet_number] = sheet\n\n# Get sheet numbers from user\nsheet_numbers_input = TaskDialog.Show(\"Print Set\", \"Enter sheet numbers separated by commas:\", TaskDialogCommonButtons.Ok | TaskDialogCommonButtons.Cancel)\n\nif sheet_numbers_input == TaskDialogResult.Cancel:\n    exit()\n\n# Get list of sheet numbers\nsheet_numbers = [num.strip() for num in TaskDialog.GetValue().split(',')]\n\n# Create a list of sheet IDs to print\nsheet_ids = List[ElementId]()\nnot_found_numbers = []\n\nfor number in sheet_numbers:\n    if number in sheets_by_number:\n        sheet_ids.Add(sheets_by_number[number].Id)\n    else:\n        not_found_numbers.append(number)\n\n# Notify about sheets not found\nif not_found_numbers:\n    TaskDialog.Show(\"Warning\", \"The following sheets were not found: \" + \", \".join(not_found_numbers))\n\n# Check if we have sheets to print\nif sheet_ids.Count == 0:\n    TaskDialog.Show(\"Error\", \"No valid sheets were specified.\")\n    exit()\n\n# Create a print set\nt = Transaction(doc, \"Create Print Set\")\nt.Start()\n\n# Create a view set\nprint_set = ViewSet()\nfor sheet_id in sheet_ids:\n    print_set.Insert(doc.GetElement(sheet_id))\n\n# Get the print manager\nprint_manager = doc.PrintManager\nprint_manager.PrintRange = PrintRange.Select\n\n# Apply print setup\nview_sheet_setting = print_manager.ViewSheetSetting\nview_sheet_setting.CurrentViewSheetSet.Views = print_set\n\n# Save the view set\nview_sheet_setting.SaveAs(\"Custom Print Set\")\n\nt.Commit()\n\nTaskDialog.Show(\"Success\", \"Print set created successfully with \" + str(sheet_ids.Count) + \" sheets.\")",
			"description": "This script creates a custom print set in Revit based on sheet numbers entered by the user. It prompts the user for a comma-separated list of sheet numbers, validates the input, and generates a named print set containing the specified sheets.",
			"likes": 0,
			"created_at": "2025-04-11T07:20:52.733439+00:00"
		},
		{
			"id": 42,
			"title": "Colorize Revit Elements by Sub-material Ratio",
			"code": "import clr\nfrom Autodesk.Revit.DB import *\nfrom Autodesk.Revit.UI import *\nimport System\nfrom System.Collections.Generic import List\nfrom System import Convert\nimport random\n\n# Get the current document\ndoc = __revit__.ActiveUIDocument.Document\nuidoc = __revit__.ActiveUIDocument\n\n# Create a transaction\nt = Transaction(doc, \"Colorize Elements by Sub-material Ratio\")\nt.Start()\n\ntry:\n    # Get all elements with the parameter \"OR_TE_Sub-material Ratio\"\n    all_elements = FilteredElementCollector(doc).WhereElementIsNotElementType().ToElements()\n    \n    elements_with_param = []\n    for element in all_elements:\n        param = element.LookupParameter(\"OR_TE_Sub-material Ratio\")\n        if param is not None and param.HasValue:\n            elements_with_param.append((element, param))\n    \n    # Create color dictionary for different parameter values\n    color_dict = {}\n    \n    # Process elements\n    for element, param in elements_with_param:\n        param_value = param.AsString()\n        \n        # Generate or retrieve color for this value\n        if param_value not in color_dict:\n            # Create a new random color\n            r = random.randint(0, 255)\n            g = random.randint(0, 255)\n            b = random.randint(0, 255)\n            color_dict[param_value] = Color(r, g, b)\n        \n        # Get element's category's material\n        category = element.Category\n        if category is not None and category.Material is not None:\n            # Get or create override settings\n            override_settings = OverrideGraphicSettings()\n            \n            # Set surface pattern to solid fill with color\n            override_settings.SetSurfaceForegroundPatternColor(color_dict[param_value])\n            override_settings.SetSurfaceForegroundPatternVisible(True)\n            \n            # Apply the override\n            doc.ActiveView.SetElementOverrides(element.Id, override_settings)\n    \n    t.Commit()\n    TaskDialog.Show(\"Success\", f\"Colorized {len(elements_with_param)} elements based on 'OR_TE_Sub-material Ratio' parameter\")\n\nexcept Exception as e:\n    t.RollBack()\n    TaskDialog.Show(\"Error\", str(e))",
			"description": "This Revit Python script colorizes elements in the active view based on the value of the 'OR_TE_Sub-material Ratio' parameter.  It assigns a unique random color to each distinct parameter value and applies an override graphic setting for elements with materials in the assigned category.",
			"likes": 0,
			"created_at": "2025-04-01T06:15:17.45443+00:00"
		},
		{
			"id": 57,
			"title": "Adjust Grid Extents to Crop Region with Offset",
			"code": "import clr\nfrom Autodesk.Revit.UI import TaskDialog\nfrom Autodesk.Revit.DB import *\nimport System.Windows.Forms\nfrom System.Windows.Forms import *\nfrom System.Drawing import *\n\ndoc = __revit__.ActiveUIDocument.Document\nuidoc = __revit__.ActiveUIDocument\nview = doc.ActiveView\n\n# Check if active view has crop region enabled\nif not view.CropBoxActive:\n    TaskDialog.Show(\"Error\", \"The active view must have a crop region enabled.\")\n    exit()\n\n# Get all grids in the current view\ncollector = FilteredElementCollector(doc, view.Id).OfCategory(BuiltInCategory.OST_Grids).WhereElementIsNotElementType()\nall_grids = list(collector)\n\nif len(all_grids) == 0:\n    TaskDialog.Show(\"Error\", \"No grids found in the current view.\")\n    exit()\n\n# Create a simple form to get the offset value\nclass OffsetForm(Form):\n    def __init__(self):\n        self.Text = \"Grid Offset from Crop Region\"\n        self.Width = 300\n        self.Height = 150\n        \n        # Offset input\n        self.label = Label()\n        self.label.Text = \"Enter offset distance (in feet):\"\n        self.label.Location = Point(20, 20)\n        self.label.Width = 250\n        \n        self.textBox = TextBox()\n        self.textBox.Text = \"0.25\"\n        self.textBox.Location = Point(20, 50)\n        self.textBox.Width = 240\n        \n        # OK and Cancel buttons\n        self.buttonOK = Button()\n        self.buttonOK.Text = \"OK\"\n        self.buttonOK.Location = Point(100, 80)\n        self.buttonOK.DialogResult = DialogResult.OK\n        \n        self.buttonCancel = Button()\n        self.buttonCancel.Text = \"Cancel\"\n        self.buttonCancel.Location = Point(180, 80)\n        self.buttonCancel.DialogResult = DialogResult.Cancel\n        \n        # Add controls to form\n        self.Controls.Add(self.label)\n        self.Controls.Add(self.textBox)\n        self.Controls.Add(self.buttonOK)\n        self.Controls.Add(self.buttonCancel)\n        \n        # Set OK as accept button\n        self.AcceptButton = self.buttonOK\n\nform = OffsetForm()\nresult = form.ShowDialog()\n\nif result != DialogResult.OK:\n    exit()\n\ntry:\n    offset_feet = float(form.textBox.Text)\nexcept:\n    TaskDialog.Show(\"Error\", \"Please enter a valid number for the offset.\")\n    exit()\n\n# Convert feet to internal Revit units\noffset = offset_feet * 1.0\n\n# Get crop box\ncrop_box = view.CropBox\n\n# Start a transaction\nt = Transaction(doc, \"Align Grids to Crop Region\")\nt.Start()\n\ntry:\n    # Process each grid\n    for grid in all_grids:\n        # Get the grid curve\n        curve = grid.Curve\n        \n        # Check if it's a line\n        if not isinstance(curve, Line):\n            continue\n            \n        # Get the direction of the line\n        direction = curve.Direction\n        \n        # Determine if grid is horizontal or vertical\n        is_horizontal = abs(direction.Y) > abs(direction.X)\n        \n        # Get the crop box boundaries\n        min_point = crop_box.Min\n        max_point = crop_box.Max\n        \n        # Calculate new start and end points based on crop box and offset\n        if is_horizontal:\n            # Horizontal grid\n            new_y = min_point.Y + offset if curve.GetEndPoint(0).Y < (min_point.Y + max_point.Y) / 2 else max_point.Y - offset\n            new_start = XYZ(min_point.X, new_y, 0)\n            new_end = XYZ(max_point.X, new_y, 0)\n        else:\n            # Vertical grid\n            new_x = min",
			"description": "This Revit Python script adjusts the extents of grids in the active view to align with the crop region boundaries, applying a user-defined offset. It prompts the user for an offset distance in feet and then modifies the grid extents accordingly.",
			"likes": 0,
			"created_at": "2025-04-08T01:42:49.69844+00:00"
		}
	],
	"total": 50
}
